<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[vault cours java]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>vault cours java</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sat, 15 Nov 2025 12:08:36 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sat, 15 Nov 2025 12:08:29 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[16. Les objets (Partie 2)]]></title><description><![CDATA[Je vous avais dit que les objets étaient un gros morceau de Java, et je n'avais pas menti ! Nous voilà déjà au round 2 !Dans la section sur <a data-tooltip-position="top" aria-label="14. Les objets (Partie 1)" data-href="14. Les objets (Partie 1)" href="cours/14.-les-objets-(partie-1).html" class="internal-link" target="_self" rel="noopener nofollow">les objets (partie 1)</a> nous avons vu comment créer une classe. On sait que :
ça sert à représenter des données plus complexes que de simples types primitifs grâce à ses champs/attributs
ça sert à définir des comportements associés à la manipulation des données grâce à ses méthodes
une instance d'une classe a des valeurs assignées grâce à un constructeur
la méthode public String toString()
​ permet permet de définir le comportement à avoir lorsqu'on veut afficher une instance de notre classe, et son comportement par défaut est moche
Maintenant, on va rentrer dans des notions liées aux classes, mais qui sont des subtilités dans l'usage qu'on en fait. Ces notions restent tout de même très importantes, puisque vous les retrouverez à peu près partout.Dans une classe, on a vu qu'on pouvait définir des attributs et des méthodes pour les instances. Mais comment on fait si on n'a pas besoin d'une instance dans certains cas ? Ou alors que certaines données ne concernent aucune instance en particulier ?Tenez, par exemple, si on prend une classe pour représenter une commande dans un magasin de e-commerce :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">JavaOrder.java1public class Order {23 private static long nextId = 1; // partagé par toutes les instances4 private long id;5 private String customerName;67 public Order(String customerName) {8 this.id = Order.nextId; // accès à la variable statique9 Order.nextId++; // on passe au suivant pour le prochain10 this.customerName = customerName;11 }1213 public static void skipNextId() {14 Order.nextId++; // celui-là ne sera pas utilisé15 }1617 public long getId() {18 return id;19 }2021 public String getCustomerName() {22 return customerName;23 }2425 @Override26 public String toString() {27 return "Order #" + id + " for " + customerName;28 }29}Pour accéder aux champs static d'une classe, on passe par le nom de la classe puis le nom de l'attribut ou de la méthode à utiliser.
static (un peu final pour pas réassigner)
visibilité (private/public/package)
héritage (protected + Object) (sealed, @Override)
final (pas d'héritage, pas d'override)
]]></description><link>cours/16.-les-objets-(partie-2).html</link><guid isPermaLink="false">cours/16. Les objets (Partie 2).md</guid><pubDate>Wed, 12 Nov 2025 22:02:38 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[index]]></title><description><![CDATA[ça se trouve <a data-tooltip-position="top" aria-label="0. Zéparti" data-href="0. Zéparti" href="cours/0.-zéparti.html" class="internal-link" target="_self" rel="noopener nofollow">ici !</a>
cast de types primitifs (on met pas un long dans un int) (à faire dans opérateurs ?)
opérateurs binaires sur 2 types différents ? (int + float = ?)
cas spécial de la concaténation de String
parler des méthodes
parler du return dans les méthodes
parler du new pour les constructeurs de classe écrire une classe semi-complète, puis l'expliquer, puis ajouter petit à petit des trucs (get, méthodes plus complexes...)
enum
trouver des idées d'exercices
parler des librairies
scope des variables
héritage (Object)
interfaces
String
Wrappers
héritage
exceptions
programmation fonctionnelle (lambdas, stream) une classe c'est un moule (une forme), une instance est une gauffre
champs static ne veut pas dire que c'est immobile (final)
méthode static (exemple des Math.pow() n'est pas lié à une instance)
on peut accéder au static depuis instance, mais pas l'inversela class à Dallasvisibilité packageUn peu de théorie avec JVM, GC, JIT, compilation, exécution...Programmation Orientée Objet<br>Jupyter notebook pour java ? <a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/forax/java-guide" target="_self">https://github.com/forax/java-guide</a>]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Wed, 12 Nov 2025 21:12:39 GMT</pubDate></item><item><title><![CDATA[Sans titre]]></title><description><![CDATA[Faites glisser depuis le bas ou double-cliquezEspace + glisser pour faire un panoramiqueCtrl + Faites défiler pour zoomer]]></description><link>cours/sans-titre.html</link><guid isPermaLink="false">cours/Sans titre.canvas</guid><pubDate>Wed, 12 Nov 2025 20:27:06 GMT</pubDate></item><item><title><![CDATA[14. Les objets (Partie 1)]]></title><description><![CDATA[
Cette section va être un peu longue, je vous préviens. Elle couvre enfin le concept le plus important de Java et il y a beaucoup de choses à raconter ici... Bonne lecture !
Java est un langage de programmation orienté objet. Ça signifie que les données peuvent être représentées sous formes d'objets. Un objet peut contenir de la donnée, avoir un comportement prédéfini, les objets peuvent interagir les uns avec les autres...Dans la section dédiée aux <a data-tooltip-position="top" aria-label="8. Variables > Types" data-href="8. Variables#Types" href="cours/8.-variables.html#Types" class="internal-link" target="_self" rel="noopener nofollow">types</a> j'ai évoqué deux catégories de types :
les types primitifs (int
​, double
​, boolean
​, ...)
les types objets (String
​, List
​, Object
​, ...)
Les premiers sont au nombre de 8. En revanche, il existe potentiellement une infinité de types objets. Pourquoi ? Parce que vous pouvez créer les vôtres !
Certains sont fournis par le JDK, comme ceux listés juste au dessus (et bien plus encore !), d'autres seront créés par vous pour vos besoins, d'autres encore pourront venir d'outils mis à dispositions par d'autres développeurs. On appelle ça des librairies. On évoquera ce sujet plus tard.
À quoi servent ces types objets ?
Bon, jusque là nos données étaient assez simples, les types primitifs faisaient l'affaire pour compter ou afficher du texte, mais je vais prendre un exemple un peu plus poussé :
Imaginez que vous devez représenter une personne. Il n'y a pas de type Person pour faire ça, alors on va le créer !
Pour notre exemple, une personne aura un nom, un prénom, un age, et à chaque fois qu'elle fête son anniversaire, son age augmente d'un an. On peut ainsi savoir si elle est mineure ou majeure.Pour ça, on va créer une classe !Pour déclarer une nouvelle classe on va réutiliser le clic-droit sur le dossier src &gt; new &gt; Java Class :<br>
<img alt="newJavaClass.png" src="images/newjavaclass.png" target="_self">On va l'appeler Person (la majuscule est importante) : <br>
<img alt="Pasted image 20251111170344.png" src="images/pasted-image-20251111170344.png" target="_self">Et voilà le résultat :public class Person { }
On va pouvoir écrire le contenu de la classe entre les accolades.public class Person { private String firstName; private String lastName; private int age; }
Ces trois lignes que vous voyez entre les accolades de la classe, ce sont ses attributs (on les appelle aussi des champs !)
On les déclare un peu comme des variables classiques dans notre main, mais en plus on leur donne une visibilité. C'est une notion qui sera largement élaborée plus tard, mais pour l'instant on va se contenter de les garder avec private
​.Ces attributs permettent de décrire comment on représente une personne. C'est une représentation simpliste, vous en conviendrez, mais il vaut mieux commencer simplement non ?Comment on fait pour manipuler notre nouvelle classe Person ? Et bien comme pour n'importe quel autre type, on va déclarer une variable et l'initialiser dans notre main !Retournons dans notre fichier Hello.java en cliquant dessus dans le panneau de gauche et modifiez sont contenu pour qu'il ressemble à ça :void main() { IO.println("Hello World!"); Person personInstance = new Person(); IO.println(personInstance);
}
<br>Puis exécutez le code comme précédemment dans la section <a data-tooltip-position="top" aria-label="5. Hello World!" data-href="5. Hello World!" href="cours/5.-hello-world!.html" class="internal-link" target="_self" rel="noopener nofollow">Hello World!</a><br><img alt="Pasted image 20251111170239.png" src="images/pasted-image-20251111170239.png" target="_self">
Ça veut dire quoi ce texte : "Person@2a84aee7" ?
C'est l'affichage par défaut d'une classe. Oui, il n'est pas très beau, on n'a aucune idée de ce que c'est que ce charabia, d'où viennent les chiffres et les lettres et puis c'est quoi ce "@" au milieu ??
Je me suis aussi posé ces questions un jour, et je ne vais pas donner tous les détails tout de suite, mais je suis d'accord pour dire que c'est moche, alors changeons ça !Une classe ne sert pas qu'à contenir des attributs, elle peut aussi contenir des méthodes pour définir son comportement !On va ajouter une méthode dans notre classe Person :public class Person { private String firstName; private String lastName; private int age; @Override public String toString() { return this.firstName + " " + this.lastName + " is " + this.age + " years old."; } }
Et maintenant on peut relancer notre programme pour voir la modification :<br><img alt="Pasted image 20251003184546.png" src="images/pasted-image-20251003184546.png" target="_self">
Bon, il se passe plusieurs choses ici... On va expliquer un peu. @Override public String toString() { return this.firstName + " " + this.lastName + " is " + this.age + " years old."; } En java, quand on déclare une classe, elle vient forcément avec une méthode qui s'appelle public String toString()
​. C'est cette méthode qui définit le comportement à avoir quand on veut représenter la classe sous forme de texte. Et c'est exactement ce qu'il se passe quand je veux l'afficher dans mon main avec IO.println(personInstance)
​.Ensuite c'est quoi le contenu de cette méthode ? On voit apparaitre this
​ : c'est le mot clé en java pour dire qu'on parle de l'instance courante. En clair, quand je veux afficher ma variable personInstance dans le main, le toString s'active et me dit qu'il faut les attributs de cet humain. On n'est pas obligé de le mettre pour que ça fonctionne. J'aurais pu écrire return firstName + " " + lastName + " is " + age + " years old."
​ pour avoir le même comportement.Et enfin, pourquoi le texte affiché est "null null is 0 years old." ? D'où sortent ces "null" et ce 0 ? Eh bien tout simplement parce que nous n'avons pas initialisé ces valeurs, alors elles ont leur valeur par défaut. Dans le cas des attributs de type String
​ c'est null et dans le cas des int
​ c'est 0 !Pour les initialiser proprement on va avoir besoin d'un constructeur.Un constructeur c'est une sorte de méthode qui permet d'initialiser les valeurs d'une instance de classe. Pour rappel, une instance, c'est un exemplaire concret de la classe. Dans votre main pour l'instant, votre classe Person n'a qu'une seule instance stockée dans la variable personInstance.
Comme on l'a vu, cette instance n'a pas encore de valeur spécifique, donc tous ses attributs sont initialisés à leur valeur par défaut (d'où les null et 0 dans l'affichage).On va donc créer le constructeur de la classe Person :public class Person { private String firstName; private String lastName; private int age; // Constructeur ici ! public Person(String firstName, String lastName, int age) { this.firstName = firstName; this.lastName = lastName; this.age = age; } @Override public String toString() { return this.firstName + " " + this.lastName + " is " + this.age + " years old."; } }
En général, quand on définit un (ou des) constructeur pour une classe, il est écrit entre les attributs et les méthodes. Je vous invite à faire de même pour qu'on se retrouve avec les mêmes conventions d'écriture.Alors, analysons ce qu'on a là...
Ça ressemble effectivement à une méthode... Un nom, des paramètres, mais pas de type de retour !
En fait, le type de retour est forcément la classe Person elle même, donc on ne le précise pas. Aussi, pour appeler un constructeur, il faut utiliser le mot clé new
​ (comme vu dans le main).
On y retrouve encore une fois ce fameux this
​ : c'est normal car maintenant on veut initialiser les attributs de cette instance.
Quand on lit la ligne this.firstName = firstName
​ il faut comprendre que ça signifie "l'attribut firstName de cette instance est initialisé à la valeur reçue via le paramètre firstName du constructeur".Là par contre, vous avez sûrement une erreur qui est apparue dans votre IDE. En effet, dans le main on nous signale que la ligne Person personInstance = new Person();
​ ne compile plus car il s'attend à trouver 3 arguments dans les parenthèses de new Person()
​. En effet, le constructeur qu'on a écrit nécessite 3 arguments : String firstName, String lastName, int age
​. Alors allons-y, on va lui en donner !
Essayez de le faire vous même sans regarder mon code immédiatement !
(Vous pouvez mettre n'importe quelle valeur du moment que ça fonctionne.)
Solution
void main() { IO.println("Hello World!"); Person personInstance = new Person("Peter", "Parker", 28); IO.println(personInstance);
} J'aime bien Spiderman
À partir de maintenant, notre variable personInstance aura les données caractérisant Peter Parker.
Les méthodes d'une classe servent à manipuler ses attributs ou à définir des comportements de la classe. Par exemple, la méthode public String toString()
​ permet de définir le comportement à avoir lorsqu'on veut représenter proprement une instance de n'importe quelle classe sous forme de texte. C'est une méthode que toutes les classes ont sans exceptions.
Par défaut, elle propose cet affichage tout moche qu'on a trouvé plus tôt : "Human@2a84aee7". En fait, par défaut, elle affiche le nom de la classe avec un arobase puis une représentation du hashCode de l'instance. C'est une notion technique qui sera abordée un peu plus tard si vous le voulez bien.
C'est grâce à cette méthode que vous verrez votre variable s'afficher proprement dans la console si vous utilisez IO.println()
​ !Comme elle est présente par défaut dans toutes les classes (comprenez, tous les types objets), il faut redéfinir son comportement pour qu'elle fasse les choses comme on en a envie.
C'est la signification du petit @Override juste au dessus de la méthode.
Sa présence n'est pas obligatoire pour que ça fonctionne, mais elle est très vivement recommandée (c'est moi qui vous y oblige !).
Il sert à vérifier que la méthode est bien redéfinie comme il faut. En effet, si vous l'appelez public String ToString()
​ au lieu de public String toString()
​ ou même public String tostring()
​, l'affichage ne fonctionnera pas car ce n'est pas le bon nom de méthode à redéfinir.
Eh oui ! Il faut être précis dans les termes !
Au moins, le @Override permettra d'afficher une erreur Method does not override method from its superclass. C'est un joli message pour dire que là vous essayez de redéfinir un truc qui n'existe pas donc ça va pas franchement marcher.<br>Vous pouvez aussi définir des méthodes personnalisées comme on l'a vu dans <a data-tooltip-position="top" aria-label="13. Les méthodes" data-href="13. Les méthodes" href="cours/13.-les-méthodes.html" class="internal-link" target="_self" rel="noopener nofollow">la section dédiée</a>. Par exemple, on peut imaginer une méthode qui nous renvoie si notre instance est mineure !public boolean isMinor() { return this.age &lt; 18; // renvoie true si age &lt; 18, false sinon
}
J'aurais aussi pu l'écrire de cette façon :public boolean isMinor() { if (this.age &lt; 18) { return true; } else { return false; } }
Les deux sont valides, mais je préfère personnellement la première.On peut noter que cette méthode est précédée d'une visibilité public
​ mais je ne vais toujours pas m'attarder dessus car comme évoqué pour les attributs private
​, c'est une notion qui sera plus largement abordée plus tard. Pour le moment je vous demande de me faire confiance.Je teste dans mon main
​ : IO.println(personInstance.isMinor());
​
Ça m'affiche bien false ! (Il a 28 ans dans mon exemple)Je peux aussi créer une méthode public void birthday()
​ qui augmente la valeur de l'âge de 1 !
Celle-ci a un type de retour void
​ car elle ne renvoie pas de valeur directement, elle change l'état interne de notre instance.public void birthday() { this.age++; }
Pour jouer avec tout ça, je teste un peu plus dans mon main
​, voilà à quoi il ressemble pour l'instant :void main() { IO.println("Hello World!"); Person personInstance = new Person("Peter", "Parker", 28); IO.println(personInstance); IO.println(personInstance.isMinor()); Person otherInstance = new Person("Miles", "Morales", 17); IO.println(otherInstance); IO.println(otherInstance.isMinor()); // true otherInstance.birthday(); // age + 1 IO.println(otherInstance.isMinor()); // false }
public class Person { private String firstName; private String lastName; private int age; public Person(String firstName, String lastName, int age) { this.firstName = firstName; this.lastName = lastName; this.age = age; } public boolean isMinor() { return this.age &lt; 18; } public void birthday() { this.age++; } @Override public String toString() { return this.firstName + " " + this.lastName + " is " + this.age + " years old."; } }
Une classe contient des données (ses champs/attributs), des comportements (ses méthodes), de quoi initialiser une instance (ses constructeurs).
Ce sont les trois principes fondamentaux pour pouvoir programmer en Java.
Certaines méthodes sont présentes dans toutes les classes par défaut (comme public String toString()
​) et peuvent être redéfinies pour avoir un comportement adapté au besoin.Les détails plus complexes que j'ai rapidement évoqués comme la visibilité, le fait que des méthodes soient présentes par défaut et bien d'autres petites fonctionnalités seront approfondies dans quelques chapitres, pour pouvoir bien les appréhender.<br>En attendant, on va s'attaquer aux <a data-tooltip-position="top" aria-label="15. Les tableaux" data-href="15. Les tableaux" href="cours/15.-les-tableaux.html" class="internal-link" target="_self" rel="noopener nofollow">tableaux</a> !]]></description><link>cours/14.-les-objets-(partie-1).html</link><guid isPermaLink="false">cours/14. Les objets (Partie 1).md</guid><pubDate>Tue, 11 Nov 2025 18:15:49 GMT</pubDate><enclosure url="images/newjavaclass.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/newjavaclass.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[15. Les tableaux]]></title><description><![CDATA[Les tableau sont ce qu'on appelle une structure de données. Ils permettent de stocker des informations.Les tableaux sont des structures de données pouvant contenir plusieurs valeurs qui partagent toutes le même <a data-tooltip-position="top" aria-label="8. Variables > Types" data-href="8. Variables#Types" href="cours/8.-variables.html#Types" class="internal-link" target="_self" rel="noopener nofollow">type</a>.Je peux déclarer et initialiser un tableau pouvant contenir par exemple 3 valeurs de type int
​ :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int[] array = new int[3];<br>Comme vu dans le <a data-tooltip-position="top" aria-label="8. Variables" data-href="8. Variables" href="cours/8.-variables.html" class="internal-link" target="_self" rel="noopener nofollow">cours sur les variables</a> je peux déclarer et initialiser un tableau sur une seule ligne. Ce qui permet de définir que c'est un tableau ce sont les crochets [] juste après le type.
int[]
​ signifie donc un tableau d'int
​. On pourrait imaginer un tableau de n'importe quoi, comme un tableau de String
​ en le déclarant comme String[]
​. Ici notre tableau s'appelle array
​.Ici, pour initialiser la valeur ça rappelle un peu la création d'instance d'une classe comme vu à la section précédente : le new int[3]
​ est effectivement un appel au constructeur du tableau !<br>
Les tableaux ne sont pas des types primitifs. Ils sont considérés comme des <a data-tooltip-position="top" aria-label="14. Les objets (Partie 1)" data-href="14. Les objets (Partie 1)" href="cours/14.-les-objets-(partie-1).html" class="internal-link" target="_self" rel="noopener nofollow">objets</a>. Comme pout tous les types objets, pour initialiser la variable je dois utiliser le mot clé new
​.
Ici, je dois aussi préciser la capacité de stockage du tableau entre les crochets de l'initialisation int[3]
​.Quand je crée un tableau, il est initialisé avec toutes ses valeurs par défaut. Comme ce tableau contient des int
​, toutes ses cases sont initialisées à 0 :<br>L'index correspond à la position de la case dans le tableau. On commence à compter à partir de 0, puis 1, 2, etc... C'est un coup à prendre mais on s'y fait au bout d'un moment. (Maintenant vous savez pourquoi je vous ai fait faire une boucle <a data-tooltip-position="top" aria-label="12. for, while, do while" data-href="12. for, while, do while" href="cours/12.-for,-while,-do-while.html" class="internal-link" target="_self" rel="noopener nofollow">for</a> qui commence à compter à partir de 0 dans le chapitre dédié aux <a data-tooltip-position="top" aria-label="12. for, while, do while" data-href="12. for, while, do while" href="cours/12.-for,-while,-do-while.html" class="internal-link" target="_self" rel="noopener nofollow">boucles</a> héhé...)On peut aussi créer un tableau avec des valeurs déjà initialisées avec une syntaxe sympa :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int[] array = new int[] {4, 2, 1};Ici je n'ai plus besoin de préciser la capacité du tableau, Java est assez malin pour voir qu'il n'y a que 3 valeurs dans les accolades !Alors on en fait quoi de ce tableau ? Eh bien on peut écrire des valeurs dans les cases ! Et comment on fait ça ? Bah en accédant aux cases avec array[0]
​, array[1]
​ et array[2]
​ !Je peux stocker 3 entiers dans ce tableau. Voilà comment je veux l'organiser :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1array[0] = 4;2array[1] = 2;3array[2] = 1;45IO.println(array[1]); // affiche 2Allez, un petit exercice pour vous !Écrivez un programme capable de faire la somme de toutes les valeurs du tableau précédemment créé et de l'afficher dans la console. Souvenez-vous que pour afficher quelque chose dans la console, on peut utiliser IO.println()
​ !Indice 1 : Ce n'est pas pour rien si je vous ai rappelé l'existence des boucles juste au dessus !
Indice 2 : Vous pouvez utiliser une variable de type int
​ dans les crochets du tableau array[indexVariable]
Indice 3 : Vous pouvez créer une variable supplémentaire pour stocker le résultatAllez je suis sympa, je vous partage ma solution. Mais ne la regardez que si vous avez réussi de votre côté, ou alors si vous ne comprenez vraiment pas ce qu'il se passe !<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">JavaTableau.java1void main() {2 int[] array = new int[] {4, 2, 1};34 int total = 0; // cette variable va me permettre de stocker le résultat56 for (int i = 0; i &lt; 3; i++) {7 total += array[i]; // je fais la somme de toutes les valeurs du tableau ici8 }910 IO.println(total);11}Ici, je crée une variable total qui va accumuler la somme des valeurs à chaque tour de la boucle. La boucle va tourner 3 fois. Une fois pour chaque case du tableau, que je vais récupérer grâce à la valeur du compteur i qui s'incrémente à chaque tour de la boucle.<br>
Si vous ne vous souvenez plus de ce que veut dire l'opérateur +=, retournez faire un tour dans le chapitre dédié aux <a data-tooltip-position="top" aria-label="9. Opérateurs > Opérateurs arithmétiques" data-href="9. Opérateurs#Opérateurs arithmétiques" href="cours/9.-opérateurs.html#Opérateurs arithmétiques" class="internal-link" target="_self" rel="noopener nofollow">opérateurs arithmétiques</a>. Il permet d'assigner à une variable la somme de sa valeur et de l'opérande donné.Comme les tableaux sont des objets, je peux accéder à des données les concernant !
Par exemple, une instance de tableau contient aussi sa propre taille, que l'on peut utiliser avec array.length
​. C'est un accès à l'attribut int length
​ de l'instance.
Ainsi, je peux écrire for (int i = 0; i &lt; array.length; i++)
​ !
C'est pratique comme ça vous pouvez écrire un programme qui fonctionne peu importe la taille du tableau !D'ailleurs, avez-vous rencontré l'erreur Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 pendant votre exercice ?
Si oui, vous avez fait l'erreur d'essayer d'accéder à une case du tableau qui n'existe pas ! Ça arrive même aux meilleurs, il faut bien se tromper de temps en temps pour apprendre !Allez, je vous montre ce qui ne va pas :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int[] array = new int[3]; 23array[0] = 1; 4array[1] = 2; 5array[2] = 4;67IO.println(array[3]); // BOOM ! Erreur ici !89/*10l'indice 3 n'existe pas dans un tableau de 3 cases11souvenez vous, on commence à compter à partir de 012donc on va jusqu'à 2 maximum !13*/Il faut donc faire attention aux valeurs de notre variable dans la boucle for
​ !À savoir !
Cette erreur est valable si vous tentez d'accéder à un index négatif, supérieur ou égal à la capacité du tableau !
<br>Bon, les tableaux sont déjà sympas pour stocker des quantités de données, mais je fais comment si j'ai besoin d'un usage plus poussé ? Eh bien on fait comme tout le monde, on utilise <a data-tooltip-position="top" aria-label="17. Les collections" data-href="17. Les collections" href="cours/17.-les-collections.html" class="internal-link" target="_self" rel="noopener nofollow">les collections</a> !]]></description><link>cours/15.-les-tableaux.html</link><guid isPermaLink="false">cours/15. Les tableaux.md</guid><pubDate>Tue, 11 Nov 2025 16:05:27 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251111170344]]></title><description><![CDATA[<img src="images/pasted-image-20251111170344.png" target="_self">]]></description><link>images/pasted-image-20251111170344.html</link><guid isPermaLink="false">images/Pasted image 20251111170344.png</guid><pubDate>Tue, 11 Nov 2025 16:03:44 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251111170239]]></title><description><![CDATA[<img src="images/pasted-image-20251111170239.png" target="_self">]]></description><link>images/pasted-image-20251111170239.html</link><guid isPermaLink="false">images/Pasted image 20251111170239.png</guid><pubDate>Tue, 11 Nov 2025 16:02:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[0. Zéparti]]></title><description><![CDATA[Vous vous lancez dans du lourd là, je vous recommande de prendre un petit carnet avec vous et de noter les trucs que vous jugez les plus pertinents, qui vous seront utiles.Surtout la règle N°1 dans le monde du développement c'est qu'il faut pratiquer, essayer, se tromper et recommencer. L'apprentissage d'un langage de programmation ne se fait pas en lisant un cours mais surtout en codant. Ce cours ne sert que de base théorique pour lancer le premier élan qui vous animera dans le développement passionné de vos idées farfelues.Quand j'aborderai une notion, plutôt que de la lire et de passer à la suivante, essayez de vous poser la question "Et moi ? Comment je l'utiliserais concrètement ?". Inventez vos propres exercices pour vous mettre à l'épreuve, ou trouvez en. Je tenterai d'en proposer quand les bases seront passées mais je ne suis pas à votre place pour déterminer que vous avez bien compris les principes abordés.En bref, la programmation ce n'est pas vraiment un travail "d'apprendre par cœur" mais surtout de "comprendre" et "maîtriser". Amusez vous bien !<a data-tooltip-position="top" aria-label="1. Java" data-href="1. Java" href="cours/1.-java.html" class="internal-link" target="_self" rel="noopener nofollow">1. C'est quoi java ?</a><br>
<a data-tooltip-position="top" aria-label="2. Fonctionnement de Java" data-href="2. Fonctionnement de Java" href="cours/2.-fonctionnement-de-java.html" class="internal-link" target="_self" rel="noopener nofollow">2. Fonctionnement de Java</a><br>
<a data-href="3. JRE ou JDK" href="cours/3.-jre-ou-jdk.html" class="internal-link" target="_self" rel="noopener nofollow">3. JRE ou JDK</a><br>
<a data-href="4. Installer un IDE" href="cours/4.-installer-un-ide.html" class="internal-link" target="_self" rel="noopener nofollow">4. Installer un IDE</a><br>
<a data-href="5. Hello World!" href="cours/5.-hello-world!.html" class="internal-link" target="_self" rel="noopener nofollow">5. Hello World!</a><br>
<a data-href="6. Structure d'un programme" href="cours/6.-structure-d'un-programme.html" class="internal-link" target="_self" rel="noopener nofollow">6. Structure d'un programme</a><br>
<a data-href="7. Syntaxe" href="cours/7.-syntaxe.html" class="internal-link" target="_self" rel="noopener nofollow">7. Syntaxe</a>7.5 diapo récap<br><a data-href="8. Variables" href="cours/8.-variables.html" class="internal-link" target="_self" rel="noopener nofollow">8. Variables</a><br>
<a data-href="9. Opérateurs" href="cours/9.-opérateurs.html" class="internal-link" target="_self" rel="noopener nofollow">9. Opérateurs</a><br>
<a data-href="10. Expression vs instruction (statement)" href="cours/10.-expression-vs-instruction-(statement).html" class="internal-link" target="_self" rel="noopener nofollow">10. Expression vs instruction (statement)</a><br>
<a data-tooltip-position="top" aria-label="11. if, switch-case" data-href="11. if, switch-case" href="cours/11.-if,-switch-case.html" class="internal-link" target="_self" rel="noopener nofollow">11. Les conditions</a><br>
<a data-tooltip-position="top" aria-label="12. for, while, do while" data-href="12. for, while, do while" href="cours/12.-for,-while,-do-while.html" class="internal-link" target="_self" rel="noopener nofollow">12. Les boucles</a>12.5 diapo recap<br><a data-href="13. Les méthodes" href="cours/13.-les-méthodes.html" class="internal-link" target="_self" rel="noopener nofollow">13. Les méthodes</a><br>
<a data-href="14. Les objets (Partie 1)" href="cours/14.-les-objets-(partie-1).html" class="internal-link" target="_self" rel="noopener nofollow">14. Les objets (Partie 1)</a><br>
<a data-href="15. Les tableaux" href="cours/15.-les-tableaux.html" class="internal-link" target="_self" rel="noopener nofollow">15. Les tableaux</a><br>
<a data-href="17. Les collections" href="cours/17.-les-collections.html" class="internal-link" target="_self" rel="noopener nofollow">17. Les collections</a>]]></description><link>cours/0.-zéparti.html</link><guid isPermaLink="false">cours/0. Zéparti.md</guid><pubDate>Tue, 11 Nov 2025 13:48:53 GMT</pubDate></item><item><title><![CDATA[4. Installer un IDE]]></title><description><![CDATA[ Bon, quand est-ce qu'on code ?
Bientôt, promis, mais pas tout de suite ! Pour pouvoir commencer à coder, il va nous falloir un outil pour écrire notre code. Et si vous avez bien suivi, il va aussi nous falloir un <a data-tooltip-position="top" aria-label="3. JRE ou JDK" data-href="3. JRE ou JDK" href="cours/3.-jre-ou-jdk.html" class="internal-link" target="_self" rel="noopener nofollow">JDK</a>. La fusion de ces deux éléments s'appelle un Environnement de Développement Intégré (IDE en anglais).Il en existe plusieurs en Java :
<br><a data-tooltip-position="top" aria-label="https://eclipseide.org/" rel="noopener nofollow" class="external-link is-unresolved" href="https://eclipseide.org/" target="_self">Eclipse</a>
<br><a data-tooltip-position="top" aria-label="https://code.visualstudio.com/" rel="noopener nofollow" class="external-link is-unresolved" href="https://code.visualstudio.com/" target="_self">VSCode</a>
<br><a data-tooltip-position="top" aria-label="https://www.jetbrains.com/idea/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.jetbrains.com/idea/" target="_self">IntelliJ IDEA</a>
...
J'utiliserai IntelliJ dans ce cours, mais si vous voulez en utiliser un autre, faites comme bon vous semble !
Je préfère IntelliJ pour sa facilité d'utilisation, son interface et ses fonctionnalités avancées que j'utilise au quotidien. Il est le choix sur lequel je me suis porté après avoir déjà essayé tous ceux cités plus haut.Je précise qu'IntelliJ existe dans 2 versions : la Community Edition et la Ultimate. La seconde est payante, nous allons donc nous tourner vers la première.
La version Ultimate propose des fonctionnalités avancées utiles pour des utilisateurs poussés dans des entreprises, nous ne raterons rien en restant sur la version gratuite.<br>On va maintenant pouvoir jouer avec notre tout premier programme : <a data-href="5. Hello World!" href="cours/5.-hello-world!.html" class="internal-link" target="_self" rel="noopener nofollow">5. Hello World!</a>]]></description><link>cours/4.-installer-un-ide.html</link><guid isPermaLink="false">cours/4. Installer un IDE.md</guid><pubDate>Sun, 02 Nov 2025 10:35:14 GMT</pubDate></item><item><title><![CDATA[13. Les méthodes]]></title><description><![CDATA[Les méthodes sont des concepts de programmations communs à de très nombreux langages de programmation aussi connues sous le nom de fonctions. C'est un peu comme en mathématiques quand on déclare f(x) = x² : on déclare une fonction dont le nom est f, qui prend un paramètre x et qui renvoie la valeur x². Si j'appelle la fonction f avec le paramètre 5 je vais obtenir le résultat 25 : f(5) = 25 !Sauf qu'ici, on va pouvoir créer des méthodes avec des noms plus explicites, des noms de variables plus élaborés, et des comportements plus complexes.En Java, une méthode est définie par sa signature. C'est à dire que la fonction à un nom, un type de retour, des paramètres (optionnel). Si je veux par exemple définir une fonction équivalente à notre bonne vieille f(x) = x² en Java, je peux l'écrire :long square(int value) { return value * value;
}
C'est quasiment la même chose ! Sauf que maintenant ma méthode est nommée square, on sait qu'elle renvoie un long
​ et prend en paramètre un int value
​.Je peux l'appeler ainsi :long result = square(5);
IO.println(result); // 25
En Java, il est possible de créer ses propres méthodes, comme je l'ai fait avec square au dessus.
Pour cela, il vous suffit de lui donner un type de retour (ou void s'il n'y en a pas), un nom et des paramètres.
Ensuite, le corps de la méthode peut contenir du code comme on l'a toujours fait jusque là !Tenez, par exemple on peut faire une méthode qui renvoie un boolean
​ pour savoir si un nombre est pair :<img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1boolean isOddNumber(int n) {2 if (n % 2 == 0) { // je vous avais dit que le modulo serait utile !3 return true;4 } else {5 return false;6 }7}<br>Et là, les super-malins pourraient remarquer que l'<a data-tooltip-position="top" aria-label="10. Expression vs instruction (statement) > Expressions" data-href="10. Expression vs instruction (statement)#Expressions" href="cours/10.-expression-vs-instruction-(statement).html#Expressions" class="internal-link" target="_self" rel="noopener nofollow">expression</a> n % 2 == 0
​ renvoie déjà un boolean
​, et que le if
​ pourrait être simplifié :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1boolean isOddNumber(int n) {2 return n % 2 == 0; // ça marche aussi3}Ça ne vous a probablement pas échappé, un nouveau mot clé à fait son apparition : return
​. C'est un mot clé utilisé dans les méthodes pour définir la valeur que la méthode va retourner (son résultat).
Une méthode ne renverra une valeur que si elle a un type de retour différent de void
​ (qui signifie l'absence de type). En l'occurence, dans les deux exemples précédents, ma méthode long square(int value)
​ a un type de retour long
​ donc elle retourne une valeur de type long
​. Ma méthode boolean isOddNumber(int n)
​ retourne un booléen avec return n % 2 == 0
​ qui renvoie soit true, soit false.Tout code écrit après un return
​ ne sera pas exécuté puisque ce mot clé permet d'arrêter l'exécution de la méthode pour renvoyer immédiatement son résultat.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1boolean isOddNumber(int n) {2 if (n % 2 == 0) {3 return true; // fin de la méthode4 IO.println("Coucou !"); // ne sera jamais exécuté5 } else {6 return false; // fin de la méthode7 IO.println("Coucou !"); // ne sera jamais exécuté8 }9}Dans ma méthode isOddNumber, j'ai deux fins alternatives : soit le nombre est pair, soit il ne l'est pas. Suivant quelle branche du if
​ est exécutée, je renverrai true ou false mais je ne verrai jamais Coucou ! s'afficher dans la console !
Pour éviter les faux espoirs, le compilateur Java ne vous permettra pas d'écrire ça, il affichera une erreur Unreachable statement pour dire que l'instruction est impossible à atteindre.Dans une méthode avec un type de retour void
​, ce mot clé peut être utilisé sans expliciter de valeur, dans le but de quitter la méthode. Il est implicitement présent à la fin de chaque méthode mais vous pouvez le rajouter vous même si vous le souhaitez !
Ça pourra être utile dans certains cas comme par exemple :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1void drinkAlcohol(int age) {2 if (age &lt; 18) {3 IO.println("Cannot dring before being 18!");4 return; // on interromp l'exécution5 }6 7 IO.println("Stay safe!");8}Dans cet exemple, le fait d'interrompre l'exécution revient au même que d'écrire :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1void drinkAlcohol(int age) {2 if (age &lt; 18) {3 IO.println("Cannot dring before being 18!");4 } else {5 IO.println("Stay safe!");6 }7}Eh oui ! Si on regarde attentivement, notre fameux main est une méthode ! Mais si ! Regardez :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1void main() { }C'est une méthode qui ne prend pas de paramètres, et renvoie void
​. C'est à dire qu'elle ne renvoie rien du tout ! Ce n'est d'ailleurs pas la seule méthode que vous utilisiez ! C'est aussi le cas de println()
​.<br>
Le cas de main est un peu spécial puisque comme évoqué dans la partie <a data-tooltip-position="top" aria-label="5. Hello World! > Explications" data-href="5. Hello World!#Explications" href="cours/5.-hello-world!.html#Explications" class="internal-link" target="_self" rel="noopener nofollow">explications sur le Hello World</a>, il est le point d'entrée du programme. Sans lui, pas d'exécution du programme !<br>Et pour boucler la boucle, on peut même relier toutes ces informations avec le concept précédemment abordé des <a data-tooltip-position="top" aria-label="10. Expression vs instruction (statement)" data-href="10. Expression vs instruction (statement)" href="cours/10.-expression-vs-instruction-(statement).html" class="internal-link" target="_self" rel="noopener nofollow">expressions et instructions</a>. Car si une méthode renvoie void
​, c'est une instruction, sinon, c'est une expression ! OMG TOUT EST LIÉ ! (oui)Les variables que vous déclarez dans une méthode ne sont visible que dans cette méthode. On dit qu'elle sont locales à la méthode.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1void main() {2 String texte = "Coucou !";3 IO.println(texte);4 afficher();5}67void afficher() {8 IO.println(texte); // ça compile pas !9}Ici, le programme ne compilera pas car la variable texte utilisée dans la fonction afficher() n'existe pas. Elle est déclarée dans la méthode main, et les variables déclarées dans une méthode ne sont visibles que depuis la méthode en question.Si je veux utiliser ma méthode afficher pour afficher des variables de mon main, il faut que je lui passe en paramètre :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1void main() {2 String texte = "Coucou !";3 IO.println(texte); // affiche bien Coucou !4 afficher(texte); // affiche bien Coucou !5}67void afficher(String str) { // maintenant la méthode a un paramètre qui s'appelle str8 IO.println(str);9}
Je rajoute un paramètre entre les parenthèses de la méthode afficher.
Ainsi, on réalise que les paramètres d'une méthode peuvent avoir n'importe quel nom, ils sont perçu comme une variable dont la valeur est attribuée par celui qui appelle la méthode. En l'occurence ici, c'est le main qui appelle afficher avec la variable texte en paramètre.Cette notion de portée des variables est applicable de façon générale à n'importe quel bloc de code. Il faut que la variable soit déclarée pour être utilisée, et il faut qu'elle soit utilisée dans l'enceinte de sa portée :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1void main() {2 int a = 5;34 for (int i = 0; i &lt; 10; i++) {5 IO.println(a);6 a = a + i;7 }8 9 IO.println(a);10 IO.println(i); // compile pas car la variable i n'est visible que dans la boucle for11}Si on veut absolument rendre ce code possible, il faut que la variable i soit déclarée en dehors de la boucle for, à la hauteur du main, exactement comme la variable a :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1void main() {2 int a = 5;3 int i = 0;45 for (; i &lt; 10; i++) { // ici je n'ai pas besoin de redéclarer i dans les parenthèses6 IO.println(a);7 a = a + i;8 }9 10 IO.println(a);11 IO.println(i); // compile !12}<br>Pour l'instant, vous ne faites qu'utiliser IO.println()
​, qui est une méthode fournie par le <a data-tooltip-position="top" aria-label="3. JRE ou JDK > JDK" data-href="3. JRE ou JDK#JDK" href="cours/3.-jre-ou-jdk.html#JDK" class="internal-link" target="_self" rel="noopener nofollow">JDK</a> mais c'est loin d'être la seule méthode disponible, et certaines seront utiles pour plus tard alors notons les ici pour pouvoir y revenir si nécessaire :
void IO.println()
​ - affiche une nouvelle ligne dans la console
void IO.println(Object obj)
​ - affiche le paramètre donné dans la console puis saute une ligne
void IO.print(Object obj)
​ - affiche le paramètre donné dans la console sans sauter de lignes
String IO.readln()
​ - lis une ligne entrée par utilisateur sur la console
String IO.readln(String prompt)
​ - affiche le paramètre donné dans la console puis lis une ligne entrée par utilisateur sur la console
<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1void main() {2 String name = IO.readln("Entrez votre nom : ");3 String age = IO.readln("Entrez votre age : ");45 IO.println("Bonjour " + name + ". Tu as " + age + " ans !");6}<br><img alt="Pasted image 20250421101825.png" src="images/pasted-image-20250421101825.png" target="_self">Comme vous l'avez peut-être remarqué, dans mon exemple juste au dessus, je demande à l'utilisateur d'entrer son age, et il est considéré comme String
​ dans le programme. Ce n'est pas une bonne idée car si j'ai besoin de faire des calculs avec cette valeur, j'ai besoin que ce soit un int
​... Alors je vous donne une dernière méthode pratique pour palier à ce genre de soucis à l'avenir : Integer.parseInt(String s)
​, qui permet de transformer la String s
​ donnée en paramètre en int
​ !
Il faut faire attention à ne pas lui donner n'importe quoi par contre, sinon le programme va planter :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int a = Integer.parseInt("35"); // renvoie un int 352int b = Integer.parseInt("Coucou !") // apocalypseEn cas d'apocalypse, le programme va vous afficher un truc du genre :
Exception in thread "main" java.lang.NumberFormatException: For input string: "Coucou !", qu'il faut comprendre comme un message d'insulte pour ne pas lui avoir donné une valeur qu'il peut convertir.Parfois quand notre programme devient complexe, il convient de le découper en différentes méthodes pour simplifier la lecture et la maintenabilité du programme.Par exemple, imaginons un jeu quelconque. Les règles sont complexes, le jeu est compliqué à coder et il serait de la folie de coder tout le programme dans le main !
Au lieu de ça, le main pourrait ressembler à ça :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1void main() {2 GameState gameState = initGameState(); // initialise la partie3 4 boolean gameOver = false;5 6 while(!gameOver) { // tant que la partie n'est pas finie7 play(gameState); // on joue8 gamerOver = checkCheckOver(gameState); // on vérifie si la partie est finie après ce tour9 }10}avec des méthodes qui contiennent la complexité du code à côté :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1GameState initGameState() {2 // ...3}45void play(GameState gameState) {6 // ...7}89boolean checkGameOver(GameState gameState) {10 // ...11}On peut imaginer que ce jeu contienne de nombreuses données complexes, comme par exemple la liste des joueurs s'il est multijoueur, ou l'échiquier d'un jeu d'échecs.<br>Dans ces cas là, il est essentiel de savoir manipuler des objets. On rentre dans le vrai morceau ! <a data-tooltip-position="top" aria-label="14. Les objets (Partie 1)" data-href="14. Les objets (Partie 1)" href="cours/14.-les-objets-(partie-1).html" class="internal-link" target="_self" rel="noopener nofollow">YEEEHAAAA !</a>]]></description><link>cours/13.-les-méthodes.html</link><guid isPermaLink="false">cours/13. Les méthodes.md</guid><pubDate>Sun, 02 Nov 2025 10:35:14 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2. Fonctionnement de Java]]></title><description><![CDATA[Ce qui a fait la popularité de Java à ses débuts, c'est son slogan "write once, run everywhere".
Sans trop rentrer dans des détails techniques inutiles, Java est un langage qui permet d'écrire des programmes compatibles sur toutes les machines capables d'installer une JVM (Java Virtual Machine).
Quand on écrit un programme, on écrit du code dans un langage lisible par des humains (Java par exemple) mais il s'avère que les ordinateurs ne savent pas lire ce programme dans l'état et sont obligés de passer ce code dans un traducteur pour machine.
Les langages de programmations sont souvent appelés des langages "haut niveau". Il y a des degré d'intensité (Java est plus haut niveau que le C par exemple) mais plus un langage est considéré haut niveau, plus il est difficile de le traduire pour la machine.Le langage que parlent les machine est appelé langage machine (oui ils sont pas allés chercher loin). Le langage machine c'est grosso-modo le langage natif d'un ordinateur. C'est comparable au fait de dire que l'ordinateur parle en binaire. Plus on se rapproche du langage machine, plus on dit qu'on est "bas niveau", en opposition avec les langages complexes qui sont plus haut niveau.
Le hic, c'est que les ordinateurs peuvent parler un langage machine différents suivant l'architecture de leur processeur (le composant qui fait office de cerveau dans l'ordinateur).
Donc si la traduction transforme notre code en langage machine, celui-ci n'est pas compris par tous les ordinateurs mais seulement par ceux qui partagent la même architecture de processeur.Conclusion : si on veut que notre programme fonctionne sur tous les ordinateurs, il faut le traduire dans tous les langages machines possibles, et il faut pour cela avoir un exemplaire de toutes les architectures possibles pour le traduire. Autant dire que c'est pas gagné !Il existe deux grandes méthodes de "traduction" vers le langage machine :
l'interprétation
la compilation
L'interpretation consiste à traduire le code en langage machine et l'exécuter immédiatement. Ça signifie que pendant l'exécution du programme, il faudra traduire en langage machine les instructions à la volée au fur et à mesure de sa progression.Un exemple typique de langage qui fonctionne avec de l'interprétation est Javascript :<img alt="Pasted image 20250402135705.png" src="images/pasted-image-20250402135705.png" target="_self">C'est à dire que pendant l'exécution du programme, l'ordinateur n'est pas concentré qu'à l'exécution mais aussi à sa traduction. Il doit jongler avec les deux tâches ! Ce jonglage constitue un certain coût dans les performances du langage.La compilation consiste à traduire tout le code de notre programme en langage machine avant de l'exécuter. C'est une méthode qui permet de produire des fichiers exécutables binaires. Ces fichiers seront spécifiques à l'architecture de l'ordinateur pour laquelle le programme a été compilé. Ils ont l'avantage d'être très rapide à exécuter. C'est par exemple le cas du langage C !<br>
<img alt="Pasted image 20250402135805.png" src="images/pasted-image-20250402135805.png" target="_self">
Ici on voit que la compilation a lieue bien avant l'exécution, donc pendant l'exécution l'ordinateur ne perd plus de temps à traduire. En contrepartie on ne peut pas utiliser l'exécutable produit par le compilateur en langage machine sur tous les ordinateurs !Java fonctionne avec un principe hybride entre ces deux concepts.
Puisqu'on ne peut pas compiler vers du langage machine ET être 100% portable sur tous les ordinateurs, on va compiler vers une étape entre deux : quelque chose qui soit plus bas niveau (donc plus facile à manipuler pour la machine) que du Java brut. En effet, souvent, plus un langage est simple à utiliser pour un humain (haut niveau), plus il est compliqué à traduire pour la machine (bas niveau), et inversement ! C'est cette tendance qui est en partie la raison pour laquelle Java a trouvé un entre-deux ! Cet entre-deux est appelé Bytecode. Voilà à quoi ça ressemble :<br><img alt="Pasted image 20250402141644.png" src="images/pasted-image-20250402141644.png" target="_self">
C'est moins glamour pour nous, mais plus compréhensible pour la machine !
Et maintenant qu'on a ce Bytecode, on peut l'interpréter pendant l'exécution sans prendre trop de temps ! Certes il faut toujours traduire ce bytecode en langage machine, mais c'est beaucoup plus simple que de traduire le Java en langage machine directement !Ça fait qu'à la fin, on a un schéma qui ressemble à ça :<br><img alt="Pasted image 20250402142717.png" src="images/pasted-image-20250402142717.png" target="_self">La JVM c'est ce fameux programme qui permet d'interpréter le bytecode. Elle possède énormément de fonctionnalités comme par exemple des algorithmes d'optimisation de code, un compilateur "Just-In-Time" qui lui permet de véritablement compiler les morceaux de code qui sont utilisés très fréquemment. En effet, c'est plus efficace de les compiler une fois et de s'en souvenir que de les réinterpréter des millions de fois ! On pourrait faire un article détaillé sur tout ce qu'elle sait faire mais ce n'est pas le but de ce résumé (qui commence à être long d'ailleurs).La grande différence entre la compilation et l'interprétation est que l'interprétation se déroule pendant l'exécution du programme. Ça a un grand impact sur les performances puisqu'avant l'exécution de chaque instruction par l'ordinateur, il faut la traduire en langage machine. La compilation a l'avantage de traduire tout le programme d'un coup avant son exécution pour ne plus avoir besoin de le faire pendant l'exécution.
La raison pour laquelle Java utilise un entre-deux est que l'interprétation du bytecode vers le langage machine est beaucoup plus rapide que si on voulait interpréter le langage directement en langage machine. Là le coût en performance serait beaucoup plus important.
Ce bytecode est donc le garant de la portabilité de nos programmes sur toutes les autres machines qui installent une JVM en maintenant un niveau de performances élevé.<br>Si vous voulez voir ces infos expliquées avec un peu plus de détails, j'ai trouvé <a data-tooltip-position="top" aria-label="https://medium.com/basecs/a-deeper-inspection-into-compilation-and-interpretation-d98952ebc842" rel="noopener nofollow" class="external-link is-unresolved" href="https://medium.com/basecs/a-deeper-inspection-into-compilation-and-interpretation-d98952ebc842" target="_self">ce site</a> qui explique superbement la différence entre l'interprétation et la compilation. Les dessins aident beaucoup et les explications sont bonnes. Je n'ai fait que résumer ce qui y est dit.Bon, maintenant il nous reste à voir comment on peut faire du Java sur notre ordinateur...<br>
<a data-tooltip-position="top" aria-label="3. JRE ou JDK" data-href="3. JRE ou JDK" href="cours/3.-jre-ou-jdk.html" class="internal-link" target="_self" rel="noopener nofollow">Allons voir ça !</a>]]></description><link>cours/2.-fonctionnement-de-java.html</link><guid isPermaLink="false">cours/2. Fonctionnement de Java.md</guid><pubDate>Sun, 02 Nov 2025 10:35:14 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3. JRE ou JDK]]></title><description><![CDATA[Il se peut qu'en cherchant à vous renseigner sur Java, vous soyez tombés sur ces acronymes.
Si vous avez déjà bidouillé sur Minecraft ou sur des logiciels Java de votre PC, il est possible que vous les ayez déjà rencontrés.Le JRE : pour Java Runtime Environment (Environnement d'Exécution Java) est techniquement une suite d'outils installés sur votre ordinateur permettant l'exécution de programmes Java.
C'est notamment dans le JRE qu'on retrouve la fameuse <a data-tooltip-position="top" aria-label="2. Fonctionnement de Java" data-href="2. Fonctionnement de Java" href="cours/2.-fonctionnement-de-java.html" class="internal-link" target="_self" rel="noopener nofollow">JVM</a>.Le JDK : pour Java Development Kit (Kit de Développement Java) est une boite à outils permettant de créer nos propres programmes Java. Il englobe le JRE à l'intérieur afin de pouvoir lancer nos propres programmes aussi.<br>
C'est notamment dans le JDK qu'on retrouve le fameux <a data-tooltip-position="top" aria-label="2. Fonctionnement de Java" data-href="2. Fonctionnement de Java" href="cours/2.-fonctionnement-de-java.html" class="internal-link" target="_self" rel="noopener nofollow">compilateur</a>.Vous l'aurez compris avec ces descriptions, dans ce cours, nous auront besoin d'un JDK afin d'écrire nos propres programmes, et puisqu'il contient un JRE ce sera suffisant pour tester nos créations.Vous noterez aussi que je parle d'un JDK et pas du JDK car il en existe plusieurs : un par version de Java. Donc nous utiliserons le JDK 25 !Les explications c'est sympa, mais ça manque de concret... Allons installer tout ça pour coder !<br>
<a data-tooltip-position="top" aria-label="4. Installer un IDE" data-href="4. Installer un IDE" href="cours/4.-installer-un-ide.html" class="internal-link" target="_self" rel="noopener nofollow">On s'y met ?</a>]]></description><link>cours/3.-jre-ou-jdk.html</link><guid isPermaLink="false">cours/3. JRE ou JDK.md</guid><pubDate>Sun, 02 Nov 2025 10:35:11 GMT</pubDate></item><item><title><![CDATA[10. Expression vs instruction (statement)]]></title><description><![CDATA[On a déjà vu qu'en Java, notre code était contenu dans des blocs de code définis par des accolades { }. Les lignes de code peuvent être de 2 natures distinctes : des expressions ou des instructions.En Java, une expression renvoie une valeur. Par exemple 3 + 4 est une expression qui renvoie 7.
3 et 4 sont eux même des expressions qui renvoient respectivement les valeurs 3 et 4.
Ainsi, les <a data-tooltip-position="top" aria-label="9. Opérateurs" data-href="9. Opérateurs" href="cours/9.-opérateurs.html" class="internal-link" target="_self" rel="noopener nofollow">opérateurs</a> servent à combiner des expressions pour en faire de nouvelles.Les expressions sont au cœur des calculs, des manipulations de données et des algorithmes en tout genre. N'importe quel code servant à calculer une valeur, un état ou générer une donnée est une expression.Exemples d'expressions :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1"Hello World!" // renvoie la String "Hello World!"20 // renvoie l'int 033 + 4 // renvoie l'int 74a == 1 // renvoie un boolean5b == c ? 'A' : 'B' // renvoie un char, soit 'A' soit 'B'Les instructions (ou statements en anglais) sont des lignes de code qui ne renvoient pas de valeur. Elles utilisent souvent des expressions pour exécuter une action.<br>Par exemple, dans notre <a data-tooltip-position="top" aria-label="5. Hello World!" data-href="5. Hello World!" href="cours/5.-hello-world!.html" class="internal-link" target="_self" rel="noopener nofollow">Hello World</a> nous avons utilisé l'instruction IO.println("Hello World!")
​. Cette instruction utilise une expression donnée entre les parenthèses pour l'afficher dans la console. Elle ne renvoie aucune valeur.Exemples d'instructions :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int a;2int b = 3;3IO.println("Bonjour");4int sum = 3 + 4;Il existe aussi des instructions plus complexes qu'on appelle des instructions de contrôles. On peut citer if, else, for, while et do while.<br>
<a data-tooltip-position="top" aria-label="11. if, switch-case" data-href="11. if, switch-case" href="cours/11.-if,-switch-case.html" class="internal-link" target="_self" rel="noopener nofollow">Apprenons à utiliser des conditions !</a>]]></description><link>cours/10.-expression-vs-instruction-(statement).html</link><guid isPermaLink="false">cours/10. Expression vs instruction (statement).md</guid><pubDate>Sun, 02 Nov 2025 10:34:58 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[6. Structure d'un programme]]></title><description><![CDATA[En Java, nous allons devoir écrire notre code avec une structure imposée par le langage.<img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">JavaHello.java1void main() {2 IO.println("Hello World!");3}
Fichier Hello.java
<br>Chaque fichier de code devra avoir une extension en .java. Par exemple, dans notre <a data-tooltip-position="top" aria-label="5. Hello World!" data-href="5. Hello World!" href="cours/5.-hello-world!.html" class="internal-link" target="_self" rel="noopener nofollow">Hello World</a> le fichier dans lequel nous avons codé s'appelle Hello.java. Il doit impérativement commencer par une MAJUSCULE. Nous verrons plus tard en quoi c'est essentiel, pour l'instant on va se contenter de le retenir comme ça.Ensuite, chaque programme nécessite un point d'entrée. Je vais me répéter car c'est important : c'est là que le programme commence, là où nous allons écrire notre code. Vous l'aurez peut-être compris, il s'agit du main. Pour que l'ordinateur sache par où commencer, il oblige notre programme à avoir un main qui lui sert de référence pour point de départ.Rappel de ce qu'est le main :Le main c'est ce qui est défini à partir de la ligne void main() {
​. La ligne se termine par une accolade ouvrante : { signifiant que tout ce qui suit est le contenu du main jusqu'à sa fermeture avec une accolade fermante : }.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1// en dehors du main23void main() {4 // contenu du main5}67// en dehors du main<br>Certaines lignes commencent par //. C'est ce qu'on appelle des commentaires. Ils ont une syntaxe particulière en Java. Attends, la syn-quoi ? <a data-tooltip-position="top" aria-label="7. Syntaxe" data-href="7. Syntaxe" href="cours/7.-syntaxe.html" class="internal-link" target="_self" rel="noopener nofollow">La syntaxe</a>.]]></description><link>cours/6.-structure-d&apos;un-programme.html</link><guid isPermaLink="false">cours/6. Structure d&apos;un programme.md</guid><pubDate>Sun, 02 Nov 2025 10:34:58 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[12. for, while, do while]]></title><description><![CDATA[Il arrive souvent qu'un programme doivent répéter une action un certain nombre de fois. Si par exemple je veux afficher à l'écran toutes les valeurs de 0 à 9 je vais avoir besoin d'utiliser 10 fois l'instruction IO.println()
​ avec une nouvelle expression entre ses parenthèses à chaque fois. (Oui, de 0 à 9 il y a 10 valeurs.)<img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1IO.println(0);2IO.println(1);3IO.println(2);4IO.println(3);5IO.println(4);6// ...7IO.println(9);C'est long et fastidieux. Au lieu de ça, il est possible de programmer des boucles.Les boucles for sont souvent utilisées quand on sait qu'on veut répéter l'action un certain nombre de fois. Il nous suffit de compter à chaque fois qu'on recommence l'action.Sa syntaxe est la suivante :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1for (/* initialisation */; /* expression booléenne */; /* mise à jour */) {2 // corps de la boucle for3}Comme pour le if, il a une syntaxe simplifiée si son corps ne contient qu'une seule instruction :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1for (/* initialisation */; /* expression booléenne */; /* mise à jour */)2 // une seule instructionLes parenthèses du for ont une grande importance car c'est ici qu'on va déclarer combien de fois le corps va s'exécuter. On sépare les différentes parties par un point-virgule ;.Dans 99% des situations, une boucle for va avoir une initialisation d'une variable de type int qui vaudra 0, qui devra atteindre une valeur strictement positive via l'expression booléenne donnée en 2ème partie et qui sera incrémentée grâce à la 3ème partie de mise à jour :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1for (int i = 0; i &lt; 10; i++) {2 IO.println(i); // cette action va se répéter 10 fois3}Ce programme est strictement identique au fait de copier/coller 10 fois comme dans l'introduction de cette partieSon exécution est assez simple à comprendre. Si je garde le même exemple voilà ce que ça donne :
j'initialise une variable i à 0
SI la condition i &lt; 10 est respectée je passe à l'étape 3, sinon je passe à l'étape 5
ALORS j'exécute le corps de la boucle
à la fin du corps de la boucle, je mets à jour i et je reviens à l'étape 2
je quitte la boucle for
Arrivera un moment où i sera égal à 10 et dans ce cas, la condition i &lt; 10 ne sera plus respectée. On quittera alors la boucle for.Il existe un autre type de boucle, plus généraliste. La boucle while.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1while (/* expression booléenne */) {2 // corps de la boucle while3}Comme tous les blocs de contrôles, on peut le simplifier en <br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1while (/* expression booléenne */)2 // une seule instructionCelle ci est à exécuter tant que la condition est vérifiée. On peut s'en servir d'une façon similaire à la boucle for rencontrée juste avant :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int i = 0;23while (i &lt; 10) {4 IO.println(i); // cette action va se répéter 10 fois5 i++; // ne surtout pas l'oublier !6}Ce code a exactement le même comportement que la boucle for au dessus.Son exécution est légèrement différente du for. Si je garde le même exemple voilà ce que ça donne :
j'initialise une variable i à 0
SI la condition i &lt; 10 est respectée je passe à l'étape 3, sinon je passe à l'étape 5
ALORS j'exécute le corps de la boucle et je reviens à l'étape 2
je quitte la boucle for
Il faut se méfier de la boucle while car il est possible d'oublier de mettre à jour notre variable i dans son corps, ce qui résulterait dans une boucle infinie !Les boucles do while sont similaires aux boucles while à une différence : avant de vérifier si la condition est respectée, une première exécution de son corps est faite.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int i = 0;23do {4 IO.println(i); // cette action va se répéter 10 fois5 i++;6} while(i &lt; 10);Son exécution est assez différente des deux autres. Si je garde le même exemple voilà ce que ça donne :
j'initialise une variable i à 0
j'exécute le corps de la boucle
SI la condition i &lt; 10 est respectée je passe à l'étape 2, sinon je passe à l'étape 4
je quitte la boucle for
Les boucles infinies font parties des erreurs de développement les plus courantes, surtout quand on débute. Si ça vous arrive, il faudra arrêter vous même le programme.
Si vous utilisez IntelliJ, utilisez le bouton stop soit dans la console, soit en haut de l'affichage.<br><img alt="Pasted image 20250325120446.png" src="images/pasted-image-20250325120446.png" target="_self"><br><img alt="Pasted image 20250325120808.png" src="images/pasted-image-20250325120808.png" target="_self">Vous pouvez d'ailleurs remarquer que ma condition i &lt; 10 est surlignée dans mon IDE. Si je passe ma souris dessus je peux vois que c'est parce qu'il me prévient que je vais faire une bêtise si j'oublie de la mettre à jour. Pratique ! Mais ça ne marche pas à tous les coups. Parfois si votre programme est trop complexe, même votre IDE ne pourra pas beaucoup vous aider donc ne vous faites pas avoir !
D'ailleurs on notera qu'il me propose de simplifier ma condition par un simple true. Non merci, ce serait délibérément me tirer une balle dans le pied. (Si vous ne comprenez pas pourquoi, essayez et jetez un oeil aux étapes de l'exécution d'une boucle pendant que votre PC brûle des calories).Je vous suggère de privilégier les boucles for aux boucles while car elles imposent de ne pas oublier l'étape de mise à jour essentielle pour ne pas tomber dans la boucle infinie. Mais il y a des cas où la boucle while est plus pratique si on ne sait pas combien de fois elle va s'exécuter et que la condition d'arrêt et la mise à jour nécessitent des calculs plus importants.
Imaginons que je code un jeu et je veux que le joueur joue jusqu'à ce qu'il perde. Tant qu'il n'a pas perdu, alors il peut jouer un nouveau coup.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1boolean perdu = false;23while (!perdu) {4 perdu = jouerUnCoup();5}Ici, jouerUnCoup()
​ sort un peu de nulle part, mais bientôt vous pourrez créer vos propres méthodes. Tiens, d'ailleurs, pourquoi pas maintenant ?<br>
<a data-tooltip-position="top" aria-label="13. Les méthodes" data-href="13. Les méthodes" href="cours/13.-les-méthodes.html" class="internal-link" target="_self" rel="noopener nofollow">Let's go !</a>]]></description><link>cours/12.-for,-while,-do-while.html</link><guid isPermaLink="false">cours/12. for, while, do while.md</guid><pubDate>Sun, 02 Nov 2025 10:34:18 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[8. Variables]]></title><description><![CDATA[Dans un programme, il nous faut des données. Ces données sont stockées dans des variables.
En Java, les variables ont obligatoirement un type. Ce n'est pas le cas dans tous les langages et c'est à la fois un énorme avantage et un inconvénient pour le développeur.
C'est quoi un type ?
C'est ce qui définit le type de contenu de la variable. Bon ok je vous donne un exemple :<img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int monChiffre = 12; // je n'oublie pas le point-virguleIci je crée une variable dont le nom est monChiffre. Le type de cette variable est int et sa valeur est 12.
int signifie integer, c'est un type qui sert à représenter les nombres entiers, qu'ils soient positifs ou négatifs.Java a 2 sortes de types : les 8 types primitifs (en minuscule) : boolean
​(*)
byte
​
char
​(*)
short
​
int
​(*)
long
​(*)
float
​
double
​(*)
(*) : ces types sont importants, retenez les les types objets (commencent par une majuscule) : String
​
List
​
Object
​
... Il n'y a techniquement pas de limites au nombre de types objets car chacun peut créer les siens. C'est un des concepts de la programmation orientée objet mais nous y reviendront plus tard. En attendant gardez cette info dans un coin de votre gigantesque cerveau.Pour déclarer une variable rien de plus simple : il vous suffit de choisir un type et un nom.
type nom;Java a aussi un type un peu particulier : void
​. Ce type (qui n'en est pas un) signifie qu'il n'y a pas de type. Il n'est pas possible de déclarer une variable de type void
​, cela n'aurait aucun sens. Mais vous l'avez pourtant déjà rencontré dans toutes les fois où vous avez vu un main :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1void main() { }<br>La raison à sa présence sera abordée dans la section sur les <a data-tooltip-position="top" aria-label="13. Les méthodes" data-href="13. Les méthodes" href="cours/13.-les-méthodes.html" class="internal-link" target="_self" rel="noopener nofollow">méthodes</a>. Patience !On peut déclarer une variable sans l'initialiser :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1byte a;2short b;3int c;4long d;5float e;6double f;7char g;8boolean h;9String i; // type objet, commence par une majuscule1011// je ne suis pas inventif sur le nom de mes variables, je saisInitialiser signifie donner une valeur. Actuellement je n'ai donné aucune valeur à ces variables, elles ont donc toutes une valeur par défaut comme l'indique la liste ci dessous :
Ok, ça fait beaucoup d'informations mais à quoi ça sert concrètement ?
En fait, un type sert à préciser la nature de la donnée. Si la donnée est un nombre entier (sans virgule), on peut utiliser les types byte, short, int ou encore long.
Leur différence relève principalement dans leur capacité à représenter de plus ou moins grands nombres. Par exemple, la valeur maximale d'un byte est 127, sa valeur minimale est -128.Ce sera au développeur de choisir le type qui convient le mieux à ses usages.L'initialisation d'une variable consiste à lui donner une valeur. On fait ça avec l'opérateur =.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int a; // a est déclarée et vaut 0 par défaut23a = 6; // a est initialisée et vaut 6Les types primitifs (qui commencent par une minuscule) les plus couramment utilisés sont int, long, double, boolean et char. Les autres sont assez peu utilisés en pratique mais vous pourriez être amenés à les rencontrer en lisant du code sur internet.Pour simplifier les choses, on peut déclarer des variables et leur assigner une valeur en un seul coup :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int a = 6;Vous l'aurez remarqué, dans la section des valeurs par défaut, certaines valeurs ont des notations curieuses. En fait pour initialiser certains types de variables il faut une notation un peu spéciale.Au même titre que pour initialiser un int on note sa valeur 3. Pour initialiser un long il faut préciser à l'ordinateur que ce n'est pas un int dans l'écriture de sa valeur. On rajoute donc un symbole pour que la machine ne confonde pas les deux : L. Donc si je veux écrire la valeur littérale d'un long qui vaut 3, il faudra écrire 3L.C'est la même chose avec le type float qui ne doit pas être confondu avec double. Comme le type double est plus couramment utilisé, on doit préciser quand il s'agit d'un float avec un F à la fin de la valeur : 3.141592F.Pour les valeurs littérales de char, on note la valeur entre guillemets simples : 'a'. <br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1char a = 'A';2char b = '?';3char c = 'Hello'; // ne marche pas
Rappel : char permet de stocker un seul caractère, une lettre est un caractère, la ponctuation aussi
Pour les valeurs littérales de String, on note la valeur entre guillemets : "Bonjour !". <br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1String a = "Bonjour !";Le compilateur de Java est capable de prouesses pour aider à rendre le développement plus simple ! Il est capable de deviner le type d'une variable si on lui demande de le faire !
Comment on s'y prend ? Avec un nouveau mot clé : var
​. Si au lieu de déclarer le type de la variable j'utilise var
​, le compilateur va se débrouiller pour deviner de quoi il s'agit :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1var a = "Bonjour !"; // a est de type String2var b = 34; // b est de type int3var c = 34L; // c est de type longC'est très pratique quand on veut gagner du temps sans avoir besoin de réfléchir au meilleur type à utiliser, le compilateur s'en charge pour vous !
Ça pose cependant un souci pour la lecture de code car vous ne savez pas quel type le compilateur a assigné à votre variable. Heureusement les IDE sont malins et vous indiquent le type des variables déclarées avec var
​ :<br><img alt="Pasted image 20250407112912.png" src="images/pasted-image-20250407112912.png" target="_self">
Je passe mon curseur de souris sur la variable c.
<br>Maintenant qu'on a des variables, on va pouvoir les manipuler avec des <a data-href="9. Opérateurs" href="cours/9.-opérateurs.html" class="internal-link" target="_self" rel="noopener nofollow">9. Opérateurs</a> !]]></description><link>cours/8.-variables.html</link><guid isPermaLink="false">cours/8. Variables.md</guid><pubDate>Sun, 02 Nov 2025 10:34:18 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[11. if, switch-case]]></title><description><![CDATA[En développement, les programmes ont besoin de conditions. C'est-à-dire que la machine va exécuter un morceau de code si une condition est respectée. C'est un élément clé de la programmation et elle est prise en charge de différentes façon en Java.Le mot clé if permet la création de condition. Sa syntaxe est la suivante :<img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1if (/* expression booléenne */) {2 // corps du if3}Si le corps du if (le bloc de code à exécuter) ne comporte qu'une seule instruction, il est possible de ne pas mettre les accolades et d'écrire simplement <br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1if (/* expression booléenne */)2 // une seule instructionvoire même <br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1if (/* expression booléenne */) // une seule instructionC'est assez rare de le voir écrit comme ça mais ça pourrait vous servir de le savoir.Ainsi, on peut évaluer des expressions booléennes, et suivant leur résultat le programme réagira d'une façon appropriée.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int variable = 95;23if (variable &gt; 90) {4 IO.println("La variable vaut plus de 90");5}Le mot clé else est à utiliser en association avec le if. Il permet de lancer du code si l'expression donnée dans le if est évaluée à false.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int variable = 95;23if (variable == 90) {4 IO.println("La variable vaut 90");5} else {6 IO.println("La variable ne vaut pas 90");7}Il est possible de tester plusieurs conditions avec des enchainements de if et else if :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int variable = -1;23if (variable == 90) {4 IO.println("La variable vaut 90");5} else if (variable &lt; 0) {6 IO.println("La valeur de la variable est négative");7} else {8 IO.println("La variable ne vaut pas 90 et n'est pas négative");9}Le programme exécutera le premier bloc de code dont la condition est vraie et n'exécutera pas les autres.
Le bloc else ne sera exécuté que si aucune des conditions au dessus n'est vérifiée. Il est à voir comme le choix par défaut si aucune condition n'est vérifiée, ça permet d'avoir des comportements par défaut dans le cas où le programme doit gérer des cas particuliers.ATTENTION, l'ordre des condition est important car si plusieurs expressions sont true, seule la première sera exécutée et toutes les autres seront ignorées.<br>Info
Le if et ses compères sont des <a data-tooltip-position="top" aria-label="10. Expression vs instruction (statement) > Instructions (statements)" data-href="10. Expression vs instruction (statement)#Instructions (statements)" href="cours/10.-expression-vs-instruction-(statement).html#Instructions (statements)" class="internal-link" target="_self" rel="noopener nofollow">instructions</a> et pas des <a data-tooltip-position="top" aria-label="10. Expression vs instruction (statement) > Expressions" data-href="10. Expression vs instruction (statement)#Expressions" href="cours/10.-expression-vs-instruction-(statement).html#Expressions" class="internal-link" target="_self" rel="noopener nofollow">expressions</a>, ils ne renvoient pas de valeurs. Il n'est donc pas possible d'avoir quelque chose comme int a = if (...)
​.
En plus du if, il existe un autre moyen de gérer des conditions dans notre code avec les blocs switch. Ils sont assez différents et leur usage est à la préférence du développeurs dans certains cas. Le switch a quelques particularités que je vais énoncer mais d'abord, regardons à quoi il ressemble :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int variable = 80;23switch (variable) {4 case 10 -&gt; {5 IO.println("variable vaut 10");6 }7 case 20, 30 -&gt; {8 IO.println("variable vaut 20 ou 30");9 }10 default -&gt; {11 IO.println("variable ne vaut ni 10, ni 20, ni 30");12 }13}Exactement comme pour le if, il a le droit à une syntaxe simplifiée quand les blocs de code ne comprennent qu'une seule ligne en retirant les accolades :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int variable = 80;23switch (variable) {4 case 10 -&gt; IO.println("variable vaut 10");5 case 20, 30 -&gt; IO.println("variable vaut 20 ou 30");6 default -&gt; IO.println("variable ne vaut ni 10, ni 20, ni 30");7}Ici il n'est pas tout à fait question de conditions mais d'égalités. On va créer un bloc case pour chaque cas à gérer selon la valeur de notre variable et un bloc default pour gérer les autres cas. On ne peut donc pas avoir de case pour gérer si la valeur est inférieur ou supérieur et on ne peut pas non plus combiner les conditions avec des &amp;&amp; (et) ou des || (ou) logiques. On peut cependant gérer plusieurs valeurs en les séparant par des virgules avec un seul case.La syntaxe avec la flèche -&gt; est assez récente (introduite dans Java 12) mais il existe une dernière syntaxe du switch qui ne doit plus être utilisée aujourd'hui. C'est une vieille syntaxe qui date de la création de Java et qui est inspirée du langage C.Je vais vous la montrer et vous l'expliquer car vous serez amenés à la rencontrer sur internet :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int variable = 80;23switch (variable) {4 case 10:5 IO.println("variable vaut 10");6 break; // break ?7 case 20:8 case 30:9 IO.println("variable vaut 20 ou 30");10 break; // encore break ?11 default:12 IO.println("variable ne vaut ni 10, ni 20, ni 30");13 break; // ENCORE break ???14}Cette syntaxe pose des problèmes car comme vous l'avez remarqué, elle comporte une ligne break à presque chaque case (sauf 20). La raison à ça est que sans la présence de ce break, les blocs des case plus bas seront exécutés même si leur condition n'est pas vérifiée.
Par exemple, le code<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int variable = 20;23switch (variable) {4 case 10:5 IO.println("variable vaut 10");6 case 20:7 IO.println("variable vaut 20");8 default:9 IO.println("variable ne vaut ni 10, ni 20");10}va m'afficher le cas case 20 et le cas default (ce qui est incorrect).Cette syntaxe est trompeuse car elle ne permet pas d'utiliser des accolades comme nous en avons l'habitude, et elle utilise deux-points : au lieu de la flèche -&gt; pour indiquer le début du bloc de code à exécuter et break pour indiquer la fin de ce bloc de code.De nombreux développeurs peuvent faire une erreur d'inattention et oublier un break quelque part, ce qui provoquerait un mauvais comportement du programme et donc un bug. Pour cette raison, la nouvelle syntaxe du switch a été introduite et doit désormais être favorisée.Il reste encore quelques particularités sur le switch (vous allez voir, il reserve encore de belles surprises que nous découvrirons dans un usage plus avancé). Parmi ces particularités, contrairement au if il est capable renvoyer une valeur ! Ce qui peut en faire une expression et pas une instruction ! Par contre, il nécessite désormais un point-virgule ; à la fin de son bloc de code. Il ne faut pas l'oublier ! (Note : Ce n'est pas le cas si le switch n'est pas utilisé comme expression)<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int variable = 80;23String resultat = switch (variable) {4 case 10 -&gt; {5 IO.println("variable vaut 10");6 yield "texte 1";7 }8 case 20, 30 -&gt; {9 IO.println("variable vaut 20 ou 30");10 yield "texte 2";11 }12 default -&gt; {13 IO.println("variable ne vaut ni 10, ni 20, ni 30");14 yield "texte 3";15 }16}; // coucou le point-virgule !1718IO.println("resultat = " + resultat);À la ligne 3, je déclare une variable et je l'initialise avec la valeur de retour du switch. Selon le cas, le mot clé yield va me renvoyer le bon texte dans resultat. Comme la valeur de variable est 80, le cas default sera exécuté et mon resultat vaudra "texte 3" !Si on exécute ce programme en le mettant dans un main, on obtiendra dans la console :1variable ne vaut ni 10, ni 20, ni 302resultat = texte 3Cette fonctionnalité est assez récente donc vous ne la trouverez peut-être pas souvent dans du vieux code, mais à l'avenir je l'utiliserai quand ce sera nécessaire dans la suite du cours donc retenez la.<br>Passons au plat de résistance, <a data-tooltip-position="top" aria-label="12. for, while, do while" data-href="12. for, while, do while" href="cours/12.-for,-while,-do-while.html" class="internal-link" target="_self" rel="noopener nofollow">les boucles !</a>]]></description><link>cours/11.-if,-switch-case.html</link><guid isPermaLink="false">cours/11. if, switch-case.md</guid><pubDate>Sun, 02 Nov 2025 10:34:14 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[9. Opérateurs]]></title><description><![CDATA[
Ok, on a des variables mais on en fait quoi ?
Eh bien on peut faire des opérations avec !Les opérateurs arithmétiques sont utiles dans les calculs avec différents types de valeurs.<img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int a = 7;2int b = 3;34int c = a + b;5// ici, la variable c vaut 10, je suis ingénieurOn a accès à des opérations de base comme :
l'addition +
la soustraction -
la multiplication *
la division /
le modulo % Modu-quoi ?
Le modulo c'est le résultat du reste de la division euclidienne. Ça n'a pas l'air très utile dit comme ça mais on trouve toujours des façon intéressantes de s'en servir, croyez moi !Par exemple, 14 % 3 vaut 2 car 14 = 4 × 3 + 2.Tout ces opérateurs sont bien classiques et je pense que vous voyez déjà comment on peut les utiliser. Ce sont des opérateurs binaires car ils prennent 2 opérandes pour calculer une valeur.Ce ne sont pas les seuls opérateurs. Il en existe d'autres plus complexes :
les shifts &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;
les opérateurs arithmétiques logiques &amp;, |, ^
On n'utilisera probablement pas ces opérateurs complexes, ou alors en guise d'exemple plus tard.
On les appelle des opérateurs bits-à-bits.<br>Cas spécial de la concaténation
L'opérateur + peut aussi servir pour combiner des variables de n'importe quel type avec des String
​ ensemble !
<img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1void main() {2 int age = 37;3 String name = "Bob";4 5 IO.println("Bonjour " + name + ". Tu as " + age + " ans !");6}
On appelle ça la concaténation de chaines de caractères et c'est très pratique !
(Il faut juste penser à mettre les espaces aux bons endroits)
Il existe aussi des opérateurs unaires :
l'incrémentation ++
la décrémentation --
Ce sont des opérateurs qui n'ont besoin que d'un opérande, et qui ajoutent et retirent respectivement 1 à la valeur.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int a = 4;23a++; // a vaut 5, son équivalent est a = a + 14a--; // a vaut de nouveau 4, son équivalent est a = a - 1
l'opérateur négatif - (pour indiquer une valeur négative)
l'opérateur négatif + (il est optionnel, pour indiquer une valeur positive)
<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int a = -4;2int b = +7; // même chose que int b = 7;34a = -a; // a vaut 4On trouve aussi les opérateurs d'assignation :
assignation =
assignation avec addition +=
assignation avec soustraction -=
assignation avec multiplication *=
assignation avec division /=
assignation avec modulo %=
Ce sont des raccourcis de notation pour une opération et une assignation en même temps :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int a = 1;23a += 3; // a vaut a + 3, donc a vaut 445// est la même chose que67a = a + 3;Les opérateurs logiques permettent de jouer avec des boolean. Ce sont eux qui permettent d'ajouter des la complexité dans nos programmes.Il y a des opérateurs pour faire des comparaisons :
strictement supérieur &gt;
strictement inférieur &lt;
supérieur ou égal &gt;=
inférieur ou égal &lt;=
égalité ==
différence !=
Ces opérateurs renvoient un boolean pour savoir si c'est vrai ou faux.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java11 &lt; 2; // true21 &gt; 2; // false32 &gt;= 2; // true43 == 4; //false53 != 4; // trueOu les opérateurs de combinaison logiques :
"et" &amp;&amp;
"ou" ||
"non" ! (opérateur unaire)
Ces opérateurs ne fonctionnent qu'avec des boolean et son utiles pour faire des calculs logiques plus complexes :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1boolean resultat = true &amp;&amp; false; // falseIl faut comprendre comment fonctionnent ces trois opérateurs car ils sont très important quand on veut ajouter de la complexité à nos programmes.L'opérateur &amp;&amp; signifie un et logique. Pour qu'il renvoie true il faut que ses deux opérandes soient true. Sinon il renvoie false.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1false &amp;&amp; false; // false2false &amp;&amp; true; // false3true &amp;&amp; false; // false4true &amp;&amp; true; // trueL'opérateur || signifie un ou logique. Pour qu'il renvoie true il faut que l'un ses deux opérandes soient true, ou les deux. Sinon il renvoie false.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1false || false; // false2false || true; // true3true || false; // true4true || true; // trueL'opérateur ! signifie un non logique. Il renvoie l'inverse de son opérande :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1!true; // false2!false; // trueIl existe un dernier opérateur logique un peu complexe : l'opérateur ternaire. Il permet de faire des choix avec 3 opérandes.<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1boolean ? valeur1 : valeur2;Il évalue le boolean et si celui ci est vrai, il renvoie la valeur1 sinon il renvoie la valeur2<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int a;23a = (3 &lt; 4) ? 1 : 2; // a = 14a = (3 &gt; 4) ? 1 : 2; // a = 2Note : les types de valeur1 et valeur2 doivent impérativement être le même que le type de aL'opérateur de cast est un opérateur unaire. (int) variable
​ (remplacez int par n'importe quel type)
Il permet de forcer Java à considérer une variable comme ayant le type indiqué entre les parenthèses. C'est un opérateur dangereux mais qui peut se révéler pratique. <br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int a = 5;2long b = (long) a; // b = 5LCet opérateur est à manipuler avec précaution car il va à l'encontre du système de typage qui permet normalement de s'assurer qu'on ne manipule pas les variables n'importe comment.Il est parfois impératif dans le cas où vous faites des opérations sur des variables qui n'ont pas le même type :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1int a = 5;2long b = 6;34int c1 = a + b; // ça ne fonctionne pas !5int c2 = (int) (a + b); // ça fonctionne !Ici, je tente de calculer la somme d'un int
​ et d'un long
​. En général, quand ce genre de choses arrive, Java va choisir le type le plus grand, ici c'est long
​. Or, un long
​ est capable d'avoir des valeurs bien plus importantes qu'un int
​. Et la machine ne sait pas si cette somme ne dépassera pas la valeur maximale que peut stocker l'int
​. Donc dans le doute elle ne permet pas cette opération.
En revanche, nous en tant que professionnels, on sait que 5 + 6 sont loin de dépasser 2147483647 (la valeur max d'un int
​) donc on peut forcer l'opération en rajoutant un cast sur la somme. En faisant ça on dit à l'ordinateur "chuut ça va aller, tout doux, je sais ce que je fais, baisse tes boucliers". Il y a des cas où c'est pratique, mais si par malheur vous ne savez pas ce que vous faites et que vous l'utilisez quand même, je ne me porte pas responsable de ce qu'il va se passer dans votre programme ! Toutes sortes de comportements étranges pourraient avoir lieus, le plus sympa étant que votre programme plante immédiatement !Les opérateurs ont tous une priorité. Par exemple, la multiplication a la priorité sur l'addition :2 + 3 * 4. C'est la même chose que 2 + (3 * 4).
On peut ajouter des parenthèses en cas de doutes ou de problèmes, mais il faut éviter de rendre la lecture trop pénible à force d'en rajouter. En général on préfère en mettre juste assez pour faciliter la compréhension en cas d'ambiguité.La liste des priorités opératoires dans l'ordre de la plus grande à la plus petite
expr++
​, expr--
​ (incrémentation/décrémentation) (*)
~
​, ++expr
​, --expr
​, +expr
​, -expr
​ (*), !expr
​ (*)
*
​, /
​, %
​ (multiplications) (*)
+
​, -
​ (additions) (*)
&lt;&lt;
​, &gt;&gt;
​, &gt;&gt;&gt;
​ (les shifts)
&lt;
​, &gt;
​, &lt;=
​, &gt;=
​, instanceof
​ (comparaison) (*)
==
​, !=
​ (égalité) (*)
&amp;
​ ("et" arithmétique logique) ^
​ ("xor" arithmétique logique)
|
​ ("ou" arithmétique logique)
&amp;&amp;
​ ("et" logique) (*)
||
​ ("ou" logique) (*)
? :
​ (opérateur ternaire) (*)
<br>J'ai noté d'une (*) ceux qui seront utilisés. Les autres sont trop complexes et peu utiles pour 99% de la population. Si vous êtes tout de même curieux je vous invite à vous renseigner sur les calculs <a data-tooltip-position="top" aria-label="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html" target="_self">bits-à-bits</a>.Gardez en tête que je n'ai pas parlé de instanceof
​ car ils nous manque des notions pour le comprendre. Il reviendra plus tard mais ce n'est pas important.Je vais vous mettre un enchainement de code, essayez de trouver la valeur de a, b, c, d et e à la fin du programme ;<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">JavaExercice.java1void main() {2 int a = 1;3 int b = 2;4 boolean c;5 boolean d;6 boolean e;78 a -= b;9 b *= 2;10 c = a &gt;= 1;1112 d = a == b &amp;&amp; !c || a &lt; b;1314 e = d || !d;15 b *= a;16 a = b &lt; 0 ? 10 : -10;17}Alors, vous avez tout suivi ?<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">JavaExercice.java1void main() {23 int a = 1;4 int b = 2;5 boolean c; // false6 boolean d; // false7 boolean e; // false89 a -= b; // a = a - b = (-1)10 b *= 2; // b = b * 2 = 411 c = a &gt;= 1; // -1 &lt; 1 donc c = false1213 /*14 je rajoute des parenthèses si la priorité n'était pas claire15 d = ((a == b) &amp;&amp; (!c)) || (a &lt; b);16 */17 d = a == b &amp;&amp; !c || a &lt; b; // false &amp;&amp; true || true donc d = true1819 e = d || !d; // e = true20 b *= a; // b = 4 * (-1) = (-4)21 a = b &lt; 0 ? 10 : -10; // a = 1022}À la fin on a donc :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1a = 10;2b = -4;3c = false;4d = true;5e = true;<br>Bon, il est temps de découvrir ce qu'on fait de ces variables avec leurs opérateurs. Elles représentent des <a data-tooltip-position="top" aria-label="10. Expression vs instruction (statement)" data-href="10. Expression vs instruction (statement)" href="cours/10.-expression-vs-instruction-(statement).html" class="internal-link" target="_self" rel="noopener nofollow">expressions</a> parfaites pour utiliser avec les bonnes <a data-tooltip-position="top" aria-label="10. Expression vs instruction (statement)" data-href="10. Expression vs instruction (statement)" href="cours/10.-expression-vs-instruction-(statement).html" class="internal-link" target="_self" rel="noopener nofollow">instructions</a> de programmation.]]></description><link>cours/9.-opérateurs.html</link><guid isPermaLink="false">cours/9. Opérateurs.md</guid><pubDate>Sun, 02 Nov 2025 10:34:07 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[7. Syntaxe]]></title><description><![CDATA[Pour rappel, la syntaxe est la combinaison de la grammaire et de l'orthographe du Java.
Elle comporte des règles qui sont obligatoires, et certaines qui sont des recommandations pour le développeur, qu'on appelle des conventions d'écritures.C'est grâce à la syntaxe précise du langage que le <a data-tooltip-position="top" aria-label="2. Fonctionnement de Java > La compilation" data-href="2. Fonctionnement de Java#La compilation" href="cours/2.-fonctionnement-de-java.html#La compilation" class="internal-link" target="_self" rel="noopener nofollow">compilateur</a> peut comprendre notre code et le traduire en bytecode. Si la syntaxe n'est pas respectée par un développeur, le compilateur va afficher des erreurs indiquant qu'il n'arrive pas à comprendre ce qu'on a voulu écrire à cause de la mauvaise syntaxe.En Java, il est possible d'écrire du texte qui est a destination du développeur et pas de la machine. Il ne fait pas partie du programme mais est présent au milieu du code pour aider à comprendre ou expliquer ce qu'il se passe. On appelle ça un commentaire et c'est très pratique !
Il existe deux façons d'en écrire :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">Java1// commentaire sur une ligne23// un autre commentaire sur une ligne45/*6Commentaire sur 7plusieurs8lignes9*/Soit on écrit // ("slash-slash") puis on ajoute notre texte juste après sur la même ligne. Ça permet d'écrire un commentaire sur une ligne. Pratique pour une petite phrase ou une courte explication.
Sinon, si on a besoin d'un commentaire plus long, on peut opter pour le commentaire sur plusieurs lignes en commençant par /* ("slash-étoile"). Tout se qui se trouve entre le début de ce commentaire et sa fin marquée par */ ("étoile-slash") sera considéré comme un commentaire et ne sera donc pas compté comme du code à exécuter.<br>Oui, j'en fais une section dédiée même si ça semble ne pas être grand chose mais en java, toutes les <a data-tooltip-position="top" aria-label="10. Expression vs instruction (statement) > Instructions (statements)" data-href="10. Expression vs instruction (statement)#Instructions (statements)" href="cours/10.-expression-vs-instruction-(statement).html#Instructions (statements)" class="internal-link" target="_self" rel="noopener nofollow">instructions</a> doivent se terminer par un point-virgule ;. Sans ça, le compilateur va se plaindre qu'il ne comprend pas ce que vous voulez dire.Quoiqu'il en soit, l'IDE saura vous indiquer les erreurs de syntaxe, et vous proposera souvent des solutions pour les corriger. Au minimum il essaiera de trouver l'origine de l'erreur pour que vous la corrigiez vous même.<br><img alt="Pasted image 20251003171742.png" src="images/pasted-image-20251003171742.png" target="_self">
"Ahhh là là, je ne vois vraiment pas ce que vous voulez dire, il manque un point virgule" - Le compilateur
Les conventions d'écriture du code sont des décisions généralement admises par les développeurs afin que le code de tout le monde respecte des règles communes pour pouvoir s'y retrouver plus facilement quand on partage du code avec des camarades.L'indentation consiste à décaler le code vers les côtés en mettant des espaces au début de la ligne dans certaines situations :
à l'ouverture d'un bloc de code, on décale vers la droite
à la fermeture d'un bloc de code, on décale vers la gauche
Un bloc de code est défini par les accolades qui l'entourent. Je peux par exemple définir un bloc de code vide : {}.La taille de l'indentation est réglable dans les paramètres de votre IDE si vous souhaitez la modifier.
Par défaut celle ci est de 4 espaces, mais j'ai tendance à préférer une indentation avec une taille de 2 espaces pour gagner de la place. C'est purement esthétique et ne changera rien au code que nous allons écrire.Voici un exemple contenant des notions que nous verrons plus tard :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">JavaExample.java1public class Example {2	// contenu de la classe34	void main() {56 // nouveau bloc de code78	} // fin du bloc de code du main, je reviens un coup à gauche910} // fin du bloc de code de la classe Example, je reviens un coup à gauche1112// je suis en dehors de la classeRetenez juste que chaque ouverture d'accolade { indique un nouveau bloc de code, donc une indentation qui se décale vers la droite.
Ne vous en faites pas trop pour la logistique des indentations, votre IDE s'en chargera pour vous à mesure que vous écrirez votre code.La taille de l'indentation est généralement admise à une valeur de 2 ou 4, ce sont les valeurs rencontrées la plupart du temps.On notera aussi les conventions de nommage. Outre le fait que les noms des fichiers doivent obligatoirement commencer par une majuscule, si ceux ci contiennent plusieurs mots on adoptera la convention appelée camelCase. Elle consiste à ajouter une majuscule à chaque nouveau mot pour améliorer la lisibilité puisqu'il n'est pas possible de les séparer par des espaces.
voilaUnExempleDePhraseEnCamelCase. Cette convention s'applique à tout se qui doit avoir un nom.Il existe d'autre conventions comme le snake_case qui consiste à écrire en minuscule et séparer les mots par des underscores _ (le tiret du bas). Celle ci n'est pas utilisée en Java mais on la retrouve dans d'autres langages comme le C par exemple.La position des accolades ouvrant un bloc de code est parfois débattue, mais la règle générale veux qu'on positionne les accolades à la fin de la ligne qui ouvre le bloc de code :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">JavaExample.java1void main() {23}Il existe une autre façon de faire moins répandue :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">JavaExample.java1void main()2{34}Techniquement ça ne change rien, mais je préfère esthétiquement la première méthode. C'est aussi celle qui est largement admise.<br>Il y a de nombreuses règles de syntaxe en Java mais nous les verrons au fur-et-à-mesure de notre progression. Par exemple, il y a une syntaxe pour déclarer et initialiser des variables. Si si ! <a data-tooltip-position="top" aria-label="8. Variables" data-href="8. Variables" href="cours/8.-variables.html" class="internal-link" target="_self" rel="noopener nofollow">Suivez moi !</a>]]></description><link>cours/7.-syntaxe.html</link><guid isPermaLink="false">cours/7. Syntaxe.md</guid><pubDate>Sun, 02 Nov 2025 10:34:07 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[5. Hello World!]]></title><description><![CDATA[ Et là, on code ??
Oui ! Ça commence ici et maintenant ! Votre IDE est désormais installé, nous allons l'utiliser !Encore une fois, j'utilise IntelliJ pour illustrer ce cours, mais soyez libre d'utiliser celui que vous voulez.<img alt="Pasted image 20250315230525.png" src="images/pasted-image-20250315230525.png" target="_self">On va créer un nouveau projet avec New Project :
Je choisis le nom de mon projet Hello Java, son emplacement dans mon ordinateur
Je sélectionne le JDK 25 (si vous n'avez pas exactement la version 25 ce n'est pas grave tant que le premier chiffre est 25)
Je décoche la case Add sample code car je vais moi même vous fournir le code du programme que l'on va essayer.
Je ne touche pas aux paramètres avancés, ils sont très bien dans l'état.
<br><img alt="Pasted image 20251003165941.png" src="images/pasted-image-20251003165941.png" target="_self">Après avoir cliqué sur Create, une installation du JDK aura lieu, l'IDE va initialiser plein de choses comme c'est son premier démarrage, c'est normal.
Vous pouvez fermer les onglets intempestifs qui se seraient ouverts (comme AI Assistant ou les notes de mises à jour par exemple).Voilà l'affichage dans l'état.<br><img alt="Pasted image 20250318144040.png" src="images/pasted-image-20250318144040.png" target="_self">L'écran est scindé en 2 :La partie gauche qui est pratique pour naviguer entre les différents fichiers du projet (à l'avenir on en aura plusieurs). Elle donne aussi accès d'autres outils utiles qu'on évoquera en temps voulu.
Pour l'instant, le plus intéressant c'est la partie centrale : l'éditeur de code.
Il est vide pour l'instant, mais pas pour longtemps !Dans la partie gauche, on distingue un dossier bleu src. C'est le dossier qui va contenir notre code source (src pour source).
Un clic droit dessus devrait vous permettre de créer un nouveau fichier :<br><img alt="Pasted image 20251003170114.png" src="images/pasted-image-20251003170114.png" target="_self">Appelez la Hello.java (n'oubliez pas la majuscule, ni le .java à la fin):<br>
<img alt="Pasted image 20251003170148.png" src="images/pasted-image-20251003170148.png" target="_self">Si jamais l'IDE vous propose de l'enregistrer via Git, vous pouvez ignorer, nous n'aborderons pas le sujet ici.Voilà donc le résultat :<br><img alt="emptyEditor.gif" src="images/emptyeditor.gif" target="_self">On voit que l'éditeur de code, à droite, est vide et s'apprète à contenir le code du fichier Hello.java et on voit aussi à gauche que le fichier Hello.java est présent dans le dossier src !Effacez le contenu de ce fichier et remplacez le par ce code :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">JavaHello.java1void main() {2 IO.println("Hello World!");3}En informatique, il est de coutume de démarrer avec ce célèbre programme qui dit bonjour ! (On est poli quand même ici)En lançant le programme à l'aide du bouton Run que vous pouvez trouver à gauche de la ligne 1, ou encore en haut vers la droite de l'interface à côté de Current File.<br><img alt="Pasted image 20251003171538.png" src="images/pasted-image-20251003171538.png" target="_self">En cliquant dessus, une autre partie de l'affichage fait son apparition : vous voyez la zone d'exécution du programme en bas de votre écran.<br><img alt="Pasted image 20251003171608.png" src="images/pasted-image-20251003171608.png" target="_self">On peut remarquer que la première ligne en bleu nous indique comment le programme a été exécuté. Si tout se passe bien, vous devriez trouver les mentions de JDK 25.On constate que le texte "Hello World!" est affiché dans la console. C'est votre tout premier programme !On voit aussi que le programme s'est fini avec un code de sortie 0. Ce qui signifie que tout s'est bien passé ! Félicitation !Avec un bout de code nous sommes parvenus à afficher du texte dans cette zone en bas de l'écran qu'on appellera la console.Décortiquons le code qu'on a sous les yeux :<br><img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">JavaHello.java1void main() {2 IO.println("Hello World!");3}Ce que vous voyez est un programme complet. Chaque programme nécessite un point d'entrée. C'est là que le programme commence, là où nous allons écrire notre code. Vous l'aurez peut-être compris, il s'agit du main. Pour que l'ordinateur sache par où commencer, il oblige notre programme à avoir un main qui lui sert de référence pour point de départ.Le main c'est ce qui est défini à partir de la ligne void main() {
​. La ligne se termine par une accolade ouvrante : { signifiant que tout ce qui suit est le contenu du main jusqu'à sa fermeture avec une accolade fermante : }.Ensuite, le contenu du main, c'est le code qui va être exécuté. En l'occurence, ici c'est IO.println("Hello World!")
​. Cette instruction est une méthode qui permet d'afficher du texte sur une ligne (c'est l'abrégé de "print line") dans la console.IO.println("Hello World!")
​ sert donc à afficher du texte dans la console.Bon. On va s'arrêter là pour le Hello World! et on va voir ce que la suite nous réserve.<br>
Tout le code qu'on va écrire se trouvera dans le main pour l'instant. La question c'est de savoir <a data-tooltip-position="top" aria-label="6. Structure d'un programme" data-href="6. Structure d'un programme" href="cours/6.-structure-d'un-programme.html" class="internal-link" target="_self" rel="noopener nofollow">comment on va l'écrire</a>.]]></description><link>cours/5.-hello-world!.html</link><guid isPermaLink="false">cours/5. Hello World!.md</guid><pubDate>Sun, 02 Nov 2025 10:32:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1. Java]]></title><description><![CDATA[Java est un langage de programmation, un outil avec lequel un développeur peut programmer en utilisant des algorithmes, des données, des opérations et tout ce qui lui passe par la tête.C'est à dire que comme n'importe quel langage, il a un vocabulaire et une grammaire qui lui est propre. On parlera de syntaxe pour parler de la "grammaire" et/ou de "l'orthographe" d'un langage de programmation.La syntaxe du Java comprend des mots clés (keywords). Ce sont des mots que le développeur utilise pour que la machine le comprenne. Eh oui, discuter avec un ordinateur demande des efforts au développeur pour s'adapter au vocabulaire la machine.
Ce sont généralement ces mots clés qui rendent le code coloré :<img class="code-styler-icon is-unresolved" src="./blob:/1f9a6e35-8be2-48fd-968b-5dee600d7b5b" target="_self">JavaToto.java1public class Toto {2	public record Data(String myField) {};34	private final int myValue = 3;5}
Exemple de coloration syntaxique
<br>Java a de nombreux mots clés : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/List_of_Java_keywords" target="_self">https://en.wikipedia.org/wiki/List_of_Java_keywords</a>
Allez y jeter un oeil rapide, vous verrez qu'il y en a quelques uns qui nous seront utiles plus tard !Java est un langage apparu en 1995. Le langage est assez âgé et a évolué depuis son apparition au travers de ses différentes versions, à commencer par la première : Java 1.0.
Depuis, les versions 1.1, 1.2 jusqu'à 1.4 sont sorties. Puis au bout d'un moment, ils se sont enfin rendu compte que le 1.X n'était pas intéressant donc ils ont décidé de renommer Java 1.5 en Java 5 (le "1." devant ne servait à rien).
Chaque version vient avec son lot de nouveautés, comme par exemple l'ajout d'un nouveau mot clé, ou la modification de l'utilisation de mots clés déjà existants pour permettre de nouvelles possibilités ou améliorer des performances par exemple.
La dernière version sortie à la date d'écriture de cet article (03/10/2025) est la version 25. Java 25 donc, est sortie le 16/09/2025.<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Java_(programming_language)#Versions" target="_self">https://en.wikipedia.org/wiki/Java_(programming_language)#Versions</a>Si vous avez cliqué sur le lien, vous aurez remarqué que certaines versions sont annotées d'un "LTS", qui signifie "Long Term Support" (Support Long Terme). Chaque version de Java sortie n'est pas garantie d'être parfaite ; et même si elle est testée en long, en large et en travers, il se peut qu'elle contienne des bugs bien cachés. Dans ces situations là, des mises à jour de la version peuvent survenir et corriger le problème. Cette chasse aux problèmes et leur résolution ne dure pas éternellement pour une version donnée. Les versions LTS bénéficient de ce traitement beaucoup plus longtemps et sont donc recommandées pour les entreprises qui préfèrent jouer la sécurité en cas de problème trouvés et corrigés.Bon, on peut se pencher sur le fonctionnement de tout ça maintenant.<br>
<a data-tooltip-position="top" aria-label="2. Fonctionnement de Java" data-href="2. Fonctionnement de Java" href="cours/2.-fonctionnement-de-java.html" class="internal-link" target="_self" rel="noopener nofollow">Let's go !</a>]]></description><link>cours/1.-java.html</link><guid isPermaLink="false">cours/1. Java.md</guid><pubDate>Sun, 02 Nov 2025 10:32:08 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[emptyEditor]]></title><description><![CDATA[<img src="images/emptyeditor.gif" target="_self">]]></description><link>images/emptyeditor.html</link><guid isPermaLink="false">images/emptyEditor.gif</guid><pubDate>Sun, 02 Nov 2025 09:59:22 GMT</pubDate><enclosure url="images/emptyeditor.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/emptyeditor.gif&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[17. Les collections]]></title><description><![CDATA[Bon, les tableaux c'est bien gentils, mais ça a ses limites.Les collections sont des classes du JDK qui permettent de stocker des éléments. Un peu comme les tableaux. Il y a cependant des différences dans les variations de ces fameuses collections.On trouve par exemple :
List
Set
Map
Queue
Deque
On va détailler les trois premières bien comme il faut, et on passera plus rapidement sur les deux dernières car ils sont moins souvent utilisés.Les listes sont des collections assez similaires à ce que font les tableaux : elles contiennent des éléments ordonnés.
Comme pour un tableau, il faut préciser ce que va contenir la liste. Sauf que là c'est un peu différent, on va utiliser une fonctionnalité de Java que je n'ai pas encore abordée : les types paramétrés. On ne va pas encore expliquer comment ils fonctionnent mais ce qu'il faut retenir c'est que quand on crée une liste, il faut préciser que c'est une liste de quelque chose. Le type des éléments de la liste doivent être précisés entre croisillons : &lt;&gt; (les symboles inférieurs et supérieurs).Par exemple, pour déclarer une variable comme étant une liste de String
​, on la déclare comme List&lt;String&gt; maListe;
​On créé une liste de la façon suivante :
List&lt;String&gt; maListe = new ArrayList&lt;String&gt;();
​
`{java}var maListe = new ArrayList();On peut ajouter un élément à la fin d'une liste, mais aussi à n'importe quelle autre position dans la liste.
maListe.add(element);
​De la même façon que pour un tableau, on peut accéder à ces valeurs à travers leur position.]]></description><link>cours/17.-les-collections.html</link><guid isPermaLink="false">cours/17. Les collections.md</guid><pubDate>Sat, 11 Oct 2025 15:35:58 GMT</pubDate></item><item><title><![CDATA[Pasted image 20251003184546]]></title><description><![CDATA[<img src="images/pasted-image-20251003184546.png" target="_self">]]></description><link>images/pasted-image-20251003184546.html</link><guid isPermaLink="false">images/Pasted image 20251003184546.png</guid><pubDate>Fri, 03 Oct 2025 16:45:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003171742]]></title><description><![CDATA[<img src="images/pasted-image-20251003171742.png" target="_self">]]></description><link>images/pasted-image-20251003171742.html</link><guid isPermaLink="false">images/Pasted image 20251003171742.png</guid><pubDate>Fri, 03 Oct 2025 15:17:42 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003171608]]></title><description><![CDATA[<img src="images/pasted-image-20251003171608.png" target="_self">]]></description><link>images/pasted-image-20251003171608.html</link><guid isPermaLink="false">images/Pasted image 20251003171608.png</guid><pubDate>Fri, 03 Oct 2025 15:16:08 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003171538]]></title><description><![CDATA[<img src="images/pasted-image-20251003171538.png" target="_self">]]></description><link>images/pasted-image-20251003171538.html</link><guid isPermaLink="false">images/Pasted image 20251003171538.png</guid><pubDate>Fri, 03 Oct 2025 15:15:38 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003170148]]></title><description><![CDATA[<img src="images/pasted-image-20251003170148.png" target="_self">]]></description><link>images/pasted-image-20251003170148.html</link><guid isPermaLink="false">images/Pasted image 20251003170148.png</guid><pubDate>Fri, 03 Oct 2025 15:01:49 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003170114]]></title><description><![CDATA[<img src="images/pasted-image-20251003170114.png" target="_self">]]></description><link>images/pasted-image-20251003170114.html</link><guid isPermaLink="false">images/Pasted image 20251003170114.png</guid><pubDate>Fri, 03 Oct 2025 15:01:14 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251003165941]]></title><description><![CDATA[<img src="images/pasted-image-20251003165941.png" target="_self">]]></description><link>images/pasted-image-20251003165941.html</link><guid isPermaLink="false">images/Pasted image 20251003165941.png</guid><pubDate>Fri, 03 Oct 2025 14:59:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250421101825]]></title><description><![CDATA[<img src="images/pasted-image-20250421101825.png" target="_self">]]></description><link>images/pasted-image-20250421101825.html</link><guid isPermaLink="false">images/Pasted image 20250421101825.png</guid><pubDate>Mon, 21 Apr 2025 08:18:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250407112912]]></title><description><![CDATA[<img src="images/pasted-image-20250407112912.png" target="_self">]]></description><link>images/pasted-image-20250407112912.html</link><guid isPermaLink="false">images/Pasted image 20250407112912.png</guid><pubDate>Mon, 07 Apr 2025 09:29:12 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250402142717]]></title><description><![CDATA[<img src="images/pasted-image-20250402142717.png" target="_self">]]></description><link>images/pasted-image-20250402142717.html</link><guid isPermaLink="false">images/Pasted image 20250402142717.png</guid><pubDate>Wed, 02 Apr 2025 12:27:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250402141644]]></title><description><![CDATA[<img src="images/pasted-image-20250402141644.png" target="_self">]]></description><link>images/pasted-image-20250402141644.html</link><guid isPermaLink="false">images/Pasted image 20250402141644.png</guid><pubDate>Wed, 02 Apr 2025 12:16:44 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250402135805]]></title><description><![CDATA[<img src="images/pasted-image-20250402135805.png" target="_self">]]></description><link>images/pasted-image-20250402135805.html</link><guid isPermaLink="false">images/Pasted image 20250402135805.png</guid><pubDate>Wed, 02 Apr 2025 11:58:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250402135705]]></title><description><![CDATA[<img src="images/pasted-image-20250402135705.png" target="_self">]]></description><link>images/pasted-image-20250402135705.html</link><guid isPermaLink="false">images/Pasted image 20250402135705.png</guid><pubDate>Wed, 02 Apr 2025 11:57:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250325120808]]></title><description><![CDATA[<img src="images/pasted-image-20250325120808.png" target="_self">]]></description><link>images/pasted-image-20250325120808.html</link><guid isPermaLink="false">images/Pasted image 20250325120808.png</guid><pubDate>Tue, 25 Mar 2025 11:08:08 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250325120446]]></title><description><![CDATA[<img src="images/pasted-image-20250325120446.png" target="_self">]]></description><link>images/pasted-image-20250325120446.html</link><guid isPermaLink="false">images/Pasted image 20250325120446.png</guid><pubDate>Tue, 25 Mar 2025 11:04:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250318144040]]></title><description><![CDATA[<img src="images/pasted-image-20250318144040.png" target="_self">]]></description><link>images/pasted-image-20250318144040.html</link><guid isPermaLink="false">images/Pasted image 20250318144040.png</guid><pubDate>Tue, 18 Mar 2025 13:40:40 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[newJavaClass]]></title><description><![CDATA[<img src="images/newjavaclass.png" target="_self">]]></description><link>images/newjavaclass.html</link><guid isPermaLink="false">images/newJavaClass.png</guid><pubDate>Tue, 18 Mar 2025 13:40:19 GMT</pubDate><enclosure url="images/newjavaclass.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/newjavaclass.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250315230525]]></title><description><![CDATA[<img src="images/pasted-image-20250315230525.png" target="_self">]]></description><link>images/pasted-image-20250315230525.html</link><guid isPermaLink="false">images/Pasted image 20250315230525.png</guid><pubDate>Sat, 15 Mar 2025 22:05:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>